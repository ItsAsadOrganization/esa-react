info: Initialized sequelize connection {"timestamp":"2023-08-12T17:41:44.860Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:41:44.960Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:41:44.961Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:41:44.961Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:41:44.962Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:41:44.979Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:41:44.980Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:41:45.036Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:41:45.038Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:41:45.045Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:42:06.001Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:42:06.095Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:42:06.095Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:42:06.096Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:42:06.097Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:42:06.112Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:42:06.113Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:42:06.158Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:42:06.159Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:42:06.166Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:44:02.423Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:44:02.523Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:44:02.523Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:44:02.524Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:44:02.524Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:44:02.538Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:44:02.539Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:44:02.581Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:44:02.582Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:44:02.589Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:44:18.432Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:44:18.523Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:44:18.523Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:44:18.524Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:44:18.525Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:44:18.541Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:44:18.542Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:44:18.583Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:44:18.584Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:44:18.591Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:45:39.954Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:45:40.049Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:45:40.049Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:45:40.050Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:45:40.051Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:45:40.066Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:45:40.066Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:45:40.109Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:45:40.110Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:45:40.118Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:45:41.514Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:45:41.606Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:45:41.607Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:45:41.607Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:45:41.608Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:45:41.623Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:45:41.623Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:45:41.666Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:45:41.666Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:45:41.674Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:46:26.217Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:46:26.312Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:46:26.312Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:46:26.313Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:46:26.314Z"}
error: Error authenticating Postgress Db object is not iterable (cannot read property Symbol(Symbol.iterator)) {"stack":"TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))\n    at connect (D:\\esa\\backend\\index.js:47:33)\n    at Server.<anonymous> (D:\\esa\\backend\\index.js:67:5)\n    at Object.onceWrapper (node:events:627:28)\n    at Server.emit (node:events:513:28)\n    at emitListeningNT (node:net:1774:10)\n    at process.processTicksAndRejections (node:internal/process/task_queues:81:21)","timestamp":"2023-08-12T17:46:26.319Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:46:26.332Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:46:26.333Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:46:26.377Z"}
debug: Executing (855a4485-4ea7-4291-9bf1-d3df17e314c0): START TRANSACTION; {"timestamp":"2023-08-12T17:46:26.378Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:46:26.379Z"}
debug: Executing (855a4485-4ea7-4291-9bf1-d3df17e314c0): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:46:26.386Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:46:26.387Z"}
debug: Executing (855a4485-4ea7-4291-9bf1-d3df17e314c0): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_f902da69f65f42d1adb15ad0e3b1e3b3$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 17:46:26.392 +00:00','2023-08-12 17:46:26.392 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_f902da69f65f42d1adb15ad0e3b1e3b3$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T17:46:26.398Z"}
debug: Executing (855a4485-4ea7-4291-9bf1-d3df17e314c0): COMMIT; {"timestamp":"2023-08-12T17:46:26.404Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:47:18.083Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:47:18.171Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:47:18.172Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:47:18.172Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:47:18.173Z"}
error: Error authenticating Postgress Db object is not iterable (cannot read property Symbol(Symbol.iterator)) {"stack":"TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))\n    at connect (D:\\esa\\backend\\index.js:47:33)\n    at Server.<anonymous> (D:\\esa\\backend\\index.js:73:5)\n    at Object.onceWrapper (node:events:627:28)\n    at Server.emit (node:events:513:28)\n    at emitListeningNT (node:net:1774:10)\n    at process.processTicksAndRejections (node:internal/process/task_queues:81:21)","timestamp":"2023-08-12T17:47:18.178Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:47:18.190Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:47:18.191Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:47:18.238Z"}
debug: Executing (00cbf944-2581-4097-aab4-a67e80ec944e): START TRANSACTION; {"timestamp":"2023-08-12T17:47:18.239Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:47:18.240Z"}
debug: Executing (00cbf944-2581-4097-aab4-a67e80ec944e): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:47:18.248Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:47:18.250Z"}
debug: Executing (00cbf944-2581-4097-aab4-a67e80ec944e): COMMIT; {"timestamp":"2023-08-12T17:47:18.254Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:47:55.011Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:47:55.102Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:47:55.102Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:47:55.103Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:47:55.104Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:47:55.121Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:47:55.122Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:47:55.166Z"}
debug: Executing (658c7335-2707-4374-bdcd-dd1ab429d167): START TRANSACTION; {"timestamp":"2023-08-12T17:47:55.167Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:47:55.169Z"}
debug: Executing (658c7335-2707-4374-bdcd-dd1ab429d167): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:47:55.176Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:47:55.178Z"}
debug: Executing (658c7335-2707-4374-bdcd-dd1ab429d167): COMMIT; {"timestamp":"2023-08-12T17:47:55.182Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:48:00.386Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:48:00.480Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:48:00.480Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:48:00.481Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:48:00.482Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:48:00.501Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:48:00.502Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:48:00.548Z"}
debug: Executing (1735dafb-a854-495f-9714-f2c0cc73f3ba): START TRANSACTION; {"timestamp":"2023-08-12T17:48:00.549Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:48:00.550Z"}
debug: Executing (1735dafb-a854-495f-9714-f2c0cc73f3ba): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:48:00.556Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:48:00.558Z"}
debug: Executing (1735dafb-a854-495f-9714-f2c0cc73f3ba): COMMIT; {"timestamp":"2023-08-12T17:48:00.562Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:48:12.228Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:48:12.314Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:48:12.315Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:48:12.315Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:48:12.316Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:48:12.332Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:48:12.333Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:48:12.376Z"}
debug: Executing (6e5682e1-a912-4693-a8b6-d921c330d3be): START TRANSACTION; {"timestamp":"2023-08-12T17:48:12.378Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:48:12.379Z"}
debug: Executing (6e5682e1-a912-4693-a8b6-d921c330d3be): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:48:12.384Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:48:12.386Z"}
debug: Executing (6e5682e1-a912-4693-a8b6-d921c330d3be): COMMIT; {"timestamp":"2023-08-12T17:48:12.391Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:48:52.714Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:48:52.804Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:48:52.805Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:48:52.805Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:48:52.806Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:48:52.822Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:48:52.822Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:48:52.870Z"}
debug: Executing (882f32af-03b2-4b4e-b8c8-90799b52d9d8): START TRANSACTION; {"timestamp":"2023-08-12T17:48:52.871Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:48:52.872Z"}
debug: Executing (882f32af-03b2-4b4e-b8c8-90799b52d9d8): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:48:52.878Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:48:52.879Z"}
debug: Executing (882f32af-03b2-4b4e-b8c8-90799b52d9d8): COMMIT; {"timestamp":"2023-08-12T17:48:52.883Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:49:01.862Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:49:01.950Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:49:01.950Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:49:01.951Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:49:01.952Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:49:01.967Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:49:01.968Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:49:02.012Z"}
debug: Executing (ba7f00c7-3a36-44cc-bf64-d3897191f3f1): START TRANSACTION; {"timestamp":"2023-08-12T17:49:02.013Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:49:02.014Z"}
debug: Executing (ba7f00c7-3a36-44cc-bf64-d3897191f3f1): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:49:02.020Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:49:02.021Z"}
debug: Executing (ba7f00c7-3a36-44cc-bf64-d3897191f3f1): COMMIT; {"timestamp":"2023-08-12T17:49:02.026Z"}
info: User Already exists {"timestamp":"2023-08-12T17:49:02.031Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:49:15.240Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:49:15.338Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:49:15.339Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:49:15.340Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:49:15.341Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:49:15.361Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:49:15.361Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:49:15.408Z"}
debug: Executing (932e9fe6-34c9-4165-b752-379c31872036): START TRANSACTION; {"timestamp":"2023-08-12T17:49:15.408Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:49:15.409Z"}
debug: Executing (932e9fe6-34c9-4165-b752-379c31872036): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:49:15.415Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:49:15.416Z"}
debug: Executing (932e9fe6-34c9-4165-b752-379c31872036): COMMIT; {"timestamp":"2023-08-12T17:49:15.421Z"}
info: User Already exists {"timestamp":"2023-08-12T17:49:15.422Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:50:16.554Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:16.642Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:50:16.642Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:16.643Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:50:16.644Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:50:16.659Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:50:16.660Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:50:16.703Z"}
debug: Executing (d8ae3dd2-c970-40e1-912e-f9f44b1de2df): START TRANSACTION; {"timestamp":"2023-08-12T17:50:16.704Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:50:16.705Z"}
debug: Executing (d8ae3dd2-c970-40e1-912e-f9f44b1de2df): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:50:16.710Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:50:16.711Z"}
debug: Executing (d8ae3dd2-c970-40e1-912e-f9f44b1de2df): COMMIT; {"timestamp":"2023-08-12T17:50:16.716Z"}
info: User Already exists {"timestamp":"2023-08-12T17:50:16.717Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:50:19.804Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:19.893Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:50:19.893Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:19.894Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:50:19.895Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:50:19.913Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:50:19.914Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:50:19.959Z"}
debug: Executing (8cb6f5d4-1056-46eb-9a6a-28c869f24218): START TRANSACTION; {"timestamp":"2023-08-12T17:50:19.960Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:50:19.960Z"}
debug: Executing (8cb6f5d4-1056-46eb-9a6a-28c869f24218): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:50:19.967Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:50:19.969Z"}
debug: Executing (8cb6f5d4-1056-46eb-9a6a-28c869f24218): COMMIT; {"timestamp":"2023-08-12T17:50:19.973Z"}
info: User Already exists {"timestamp":"2023-08-12T17:50:19.974Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:50:25.791Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:25.878Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:50:25.879Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:25.880Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:50:25.880Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:50:25.896Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:50:25.897Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:50:25.944Z"}
debug: Executing (3cf8682e-d867-438e-8dc9-fdf49bff52a9): START TRANSACTION; {"timestamp":"2023-08-12T17:50:25.945Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:50:25.946Z"}
debug: Executing (3cf8682e-d867-438e-8dc9-fdf49bff52a9): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:50:25.952Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:50:25.954Z"}
debug: Executing (3cf8682e-d867-438e-8dc9-fdf49bff52a9): COMMIT; {"timestamp":"2023-08-12T17:50:25.959Z"}
info: User Already exists {"timestamp":"2023-08-12T17:50:25.960Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:50:39.606Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:39.699Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:50:39.700Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:39.700Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:50:39.701Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:50:39.719Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:50:39.720Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:50:39.768Z"}
debug: Executing (3ba9a264-2588-45c5-b2a1-68b688b622c4): START TRANSACTION; {"timestamp":"2023-08-12T17:50:39.769Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:50:39.770Z"}
debug: Executing (3ba9a264-2588-45c5-b2a1-68b688b622c4): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:50:39.776Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:50:39.778Z"}
debug: Executing (3ba9a264-2588-45c5-b2a1-68b688b622c4): COMMIT; {"timestamp":"2023-08-12T17:50:39.784Z"}
info: User Already exists {"timestamp":"2023-08-12T17:50:39.785Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:50:46.044Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:46.139Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:50:46.140Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:46.140Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:50:46.141Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:50:46.160Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:50:46.161Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:50:46.225Z"}
debug: Executing (746cffbc-836f-4e3c-96db-6ef8bcd30fb8): START TRANSACTION; {"timestamp":"2023-08-12T17:50:46.227Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:50:46.228Z"}
debug: Executing (746cffbc-836f-4e3c-96db-6ef8bcd30fb8): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:50:46.235Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:50:46.237Z"}
debug: Executing (746cffbc-836f-4e3c-96db-6ef8bcd30fb8): COMMIT; {"timestamp":"2023-08-12T17:50:46.241Z"}
info: User Already exists {"timestamp":"2023-08-12T17:50:46.243Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:50:47.008Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:47.097Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:50:47.097Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:47.098Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:50:47.099Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:50:47.114Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:50:47.115Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:50:47.160Z"}
debug: Executing (7ee9b3df-768f-46bf-a75e-96d84cbda4b9): START TRANSACTION; {"timestamp":"2023-08-12T17:50:47.160Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:50:47.161Z"}
debug: Executing (7ee9b3df-768f-46bf-a75e-96d84cbda4b9): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:50:47.168Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:50:47.169Z"}
debug: Executing (7ee9b3df-768f-46bf-a75e-96d84cbda4b9): COMMIT; {"timestamp":"2023-08-12T17:50:47.173Z"}
info: User Already exists {"timestamp":"2023-08-12T17:50:47.174Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:50:55.118Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:55.210Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:50:55.211Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:50:55.212Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:50:55.213Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:50:55.229Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:50:55.230Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:50:55.275Z"}
debug: Executing (97ed679b-6525-4df1-bdc8-9d5211e5266e): START TRANSACTION; {"timestamp":"2023-08-12T17:50:55.278Z"}
debug: Executing (97ed679b-6525-4df1-bdc8-9d5211e5266e): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:50:55.285Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:50:55.286Z"}
debug: Executing (97ed679b-6525-4df1-bdc8-9d5211e5266e): COMMIT; {"timestamp":"2023-08-12T17:50:55.291Z"}
info: User Already exists {"timestamp":"2023-08-12T17:50:55.292Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:50:55.293Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:51:01.819Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:01.909Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:51:01.909Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:01.910Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:51:01.911Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:51:01.928Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:51:01.929Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:51:01.977Z"}
debug: Executing (697d3b98-9b94-4fce-b612-8cac2d96ce4d): START TRANSACTION; {"timestamp":"2023-08-12T17:51:01.979Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:51:01.980Z"}
debug: Executing (697d3b98-9b94-4fce-b612-8cac2d96ce4d): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:51:01.986Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:01.988Z"}
debug: Executing (697d3b98-9b94-4fce-b612-8cac2d96ce4d): COMMIT; {"timestamp":"2023-08-12T17:51:01.993Z"}
info: User Already exists {"timestamp":"2023-08-12T17:51:01.994Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:51:06.713Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:06.800Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:51:06.800Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:06.801Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:51:06.802Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:51:06.817Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:51:06.818Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:51:06.864Z"}
debug: Executing (0ad7c7eb-d2f6-4b58-b53e-0eb129889b3f): START TRANSACTION; {"timestamp":"2023-08-12T17:51:06.864Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:51:06.865Z"}
debug: Executing (0ad7c7eb-d2f6-4b58-b53e-0eb129889b3f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:51:06.871Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:06.873Z"}
debug: Executing (0ad7c7eb-d2f6-4b58-b53e-0eb129889b3f): COMMIT; {"timestamp":"2023-08-12T17:51:06.877Z"}
info: User Already exists {"timestamp":"2023-08-12T17:51:06.878Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:51:13.414Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:13.506Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:51:13.507Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:13.507Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:51:13.508Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:51:13.524Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:51:13.524Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:51:13.568Z"}
debug: Executing (76b8aa7c-ae25-4bf1-8365-50b137b28375): START TRANSACTION; {"timestamp":"2023-08-12T17:51:13.569Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:51:13.570Z"}
debug: Executing (76b8aa7c-ae25-4bf1-8365-50b137b28375): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:51:13.575Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:13.577Z"}
debug: Executing (76b8aa7c-ae25-4bf1-8365-50b137b28375): COMMIT; {"timestamp":"2023-08-12T17:51:13.581Z"}
info: User Already exists {"timestamp":"2023-08-12T17:51:13.582Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:51:13.585Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T17:51:13.589Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:13.596Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:51:40.278Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:40.385Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:51:40.385Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:40.386Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:51:40.387Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:51:40.407Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:51:40.409Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:51:40.463Z"}
debug: Executing (d8d9ba1c-5744-4ae1-bbc0-2fd1fa954df9): START TRANSACTION; {"timestamp":"2023-08-12T17:51:40.464Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:51:40.467Z"}
debug: Executing (d8d9ba1c-5744-4ae1-bbc0-2fd1fa954df9): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:51:40.473Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:40.476Z"}
debug: Executing (d8d9ba1c-5744-4ae1-bbc0-2fd1fa954df9): COMMIT; {"timestamp":"2023-08-12T17:51:40.481Z"}
info: User Already exists {"timestamp":"2023-08-12T17:51:40.482Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:51:40.486Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:40.489Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:51:47.822Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:47.921Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:51:47.921Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:47.922Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:51:47.923Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:51:47.939Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:51:47.940Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:51:47.990Z"}
debug: Executing (20e9142a-bd0d-4349-b4d0-bde6d0cd931f): START TRANSACTION; {"timestamp":"2023-08-12T17:51:47.991Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:51:47.991Z"}
debug: Executing (20e9142a-bd0d-4349-b4d0-bde6d0cd931f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:51:47.999Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:48.000Z"}
debug: Executing (20e9142a-bd0d-4349-b4d0-bde6d0cd931f): COMMIT; {"timestamp":"2023-08-12T17:51:48.006Z"}
info: User Already exists {"timestamp":"2023-08-12T17:51:48.007Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:51:48.010Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:48.013Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:51:51.469Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:51.556Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:51:51.557Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:51.558Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:51:51.558Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:51:51.574Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:51:51.575Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:51:51.619Z"}
debug: Executing (9c1d1d53-7f77-42a0-a878-fb187a32e3d4): START TRANSACTION; {"timestamp":"2023-08-12T17:51:51.621Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:51:51.622Z"}
debug: Executing (9c1d1d53-7f77-42a0-a878-fb187a32e3d4): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:51:51.628Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:51.632Z"}
debug: Executing (9c1d1d53-7f77-42a0-a878-fb187a32e3d4): COMMIT; {"timestamp":"2023-08-12T17:51:51.634Z"}
info: User Already exists {"timestamp":"2023-08-12T17:51:51.635Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:51:51.640Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:51.642Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:51:55.621Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:55.714Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:51:55.714Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:51:55.715Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:51:55.716Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:51:55.733Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:51:55.733Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:51:55.777Z"}
debug: Executing (ffa70374-3347-4ce3-8647-09dc65e04332): START TRANSACTION; {"timestamp":"2023-08-12T17:51:55.779Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:51:55.779Z"}
debug: Executing (ffa70374-3347-4ce3-8647-09dc65e04332): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:51:55.786Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:55.787Z"}
debug: Executing (ffa70374-3347-4ce3-8647-09dc65e04332): COMMIT; {"timestamp":"2023-08-12T17:51:55.793Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:51:55.795Z"}
info: User Already exists {"timestamp":"2023-08-12T17:51:55.796Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:51:55.798Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:52:02.716Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:52:02.821Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:52:02.821Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:52:02.822Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:52:02.822Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:52:02.839Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:52:02.840Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:52:02.884Z"}
debug: Executing (f16fc8a8-3b18-4552-af92-129edeef8e19): START TRANSACTION; {"timestamp":"2023-08-12T17:52:02.885Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:52:02.887Z"}
debug: Executing (f16fc8a8-3b18-4552-af92-129edeef8e19): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:52:02.892Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:52:02.894Z"}
debug: Executing (f16fc8a8-3b18-4552-af92-129edeef8e19): COMMIT; {"timestamp":"2023-08-12T17:52:02.898Z"}
info: User Already exists {"timestamp":"2023-08-12T17:52:02.900Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:52:02.904Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:52:02.907Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:52:06.812Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:52:06.902Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:52:06.903Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:52:06.903Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:52:06.904Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:52:06.918Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:52:06.919Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:52:06.963Z"}
debug: Executing (fbfdc455-962f-44f5-b38a-12b5658fe1b4): START TRANSACTION; {"timestamp":"2023-08-12T17:52:06.964Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:52:06.964Z"}
debug: Executing (fbfdc455-962f-44f5-b38a-12b5658fe1b4): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:52:06.970Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:52:06.971Z"}
debug: Executing (fbfdc455-962f-44f5-b38a-12b5658fe1b4): COMMIT; {"timestamp":"2023-08-12T17:52:06.976Z"}
info: User Already exists {"timestamp":"2023-08-12T17:52:06.977Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:52:06.980Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:52:06.982Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:58:45.344Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:58:45.436Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:58:45.437Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:58:45.437Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:58:45.438Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:58:45.452Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:58:45.453Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:58:45.493Z"}
debug: Executing (8c2878b7-f4de-48e7-9271-c60db8a6bf42): START TRANSACTION; {"timestamp":"2023-08-12T17:58:45.493Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:58:45.494Z"}
debug: Executing (8c2878b7-f4de-48e7-9271-c60db8a6bf42): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:58:45.500Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:58:45.502Z"}
debug: Executing (8c2878b7-f4de-48e7-9271-c60db8a6bf42): COMMIT; {"timestamp":"2023-08-12T17:58:45.506Z"}
info: User Already exists {"timestamp":"2023-08-12T17:58:45.507Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:58:45.509Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:58:45.512Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:58:55.891Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:58:55.979Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:58:55.980Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:58:55.980Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:58:55.981Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:58:55.995Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:58:55.995Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:58:56.038Z"}
debug: Executing (34bf74c3-61a4-44c0-b9f2-321bbce4db7c): START TRANSACTION; {"timestamp":"2023-08-12T17:58:56.039Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:58:56.039Z"}
debug: Executing (34bf74c3-61a4-44c0-b9f2-321bbce4db7c): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:58:56.044Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:58:56.046Z"}
debug: Executing (34bf74c3-61a4-44c0-b9f2-321bbce4db7c): COMMIT; {"timestamp":"2023-08-12T17:58:56.050Z"}
info: User Already exists {"timestamp":"2023-08-12T17:58:56.051Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:58:56.053Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:58:56.056Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:59:03.697Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:03.780Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:59:03.781Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:03.782Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:59:03.782Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:59:03.797Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:59:03.798Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:59:03.840Z"}
debug: Executing (1b734039-74c8-4cd0-b722-70ff38f7e9b6): START TRANSACTION; {"timestamp":"2023-08-12T17:59:03.840Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:59:03.841Z"}
debug: Executing (1b734039-74c8-4cd0-b722-70ff38f7e9b6): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:59:03.847Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:03.849Z"}
debug: Executing (1b734039-74c8-4cd0-b722-70ff38f7e9b6): COMMIT; {"timestamp":"2023-08-12T17:59:03.853Z"}
info: User Already exists {"timestamp":"2023-08-12T17:59:03.854Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:59:03.857Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:03.859Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:59:07.739Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:07.832Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:59:07.833Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:07.834Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:59:07.834Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:59:07.849Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:59:07.850Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:59:07.891Z"}
debug: Executing (01d156b3-de07-42c0-bd94-cb0b61fa6de1): START TRANSACTION; {"timestamp":"2023-08-12T17:59:07.893Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:59:07.894Z"}
debug: Executing (01d156b3-de07-42c0-bd94-cb0b61fa6de1): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:59:07.900Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:07.902Z"}
debug: Executing (01d156b3-de07-42c0-bd94-cb0b61fa6de1): COMMIT; {"timestamp":"2023-08-12T17:59:07.906Z"}
info: User Already exists {"timestamp":"2023-08-12T17:59:07.907Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:59:07.909Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:07.911Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:59:16.523Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:16.614Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:59:16.615Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:16.616Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:59:16.617Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:59:16.628Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:59:16.629Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:59:16.672Z"}
debug: Executing (b49d94ed-c4e4-4995-8ab2-5e50bcd68e2d): START TRANSACTION; {"timestamp":"2023-08-12T17:59:16.673Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:59:16.673Z"}
debug: Executing (b49d94ed-c4e4-4995-8ab2-5e50bcd68e2d): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:59:16.682Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:16.683Z"}
debug: Executing (b49d94ed-c4e4-4995-8ab2-5e50bcd68e2d): COMMIT; {"timestamp":"2023-08-12T17:59:16.688Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:59:16.691Z"}
info: User Already exists {"timestamp":"2023-08-12T17:59:16.691Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:16.694Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:59:22.226Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:22.311Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:59:22.311Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:22.312Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:59:22.313Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:59:22.327Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:59:22.328Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:59:22.368Z"}
debug: Executing (843a41a3-07bf-4c20-82da-46bc695a6edf): START TRANSACTION; {"timestamp":"2023-08-12T17:59:22.369Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:59:22.369Z"}
debug: Executing (843a41a3-07bf-4c20-82da-46bc695a6edf): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:59:22.375Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:22.376Z"}
debug: Executing (843a41a3-07bf-4c20-82da-46bc695a6edf): COMMIT; {"timestamp":"2023-08-12T17:59:22.381Z"}
info: User Already exists {"timestamp":"2023-08-12T17:59:22.382Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:59:22.384Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:22.387Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:59:31.539Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:31.625Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:59:31.626Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:31.626Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:59:31.627Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:59:31.638Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:59:31.639Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:59:31.679Z"}
debug: Executing (710201e3-756e-4893-bf1b-ab341cce2c1c): START TRANSACTION; {"timestamp":"2023-08-12T17:59:31.680Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:59:31.682Z"}
debug: Executing (710201e3-756e-4893-bf1b-ab341cce2c1c): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:59:31.687Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:31.688Z"}
debug: Executing (710201e3-756e-4893-bf1b-ab341cce2c1c): COMMIT; {"timestamp":"2023-08-12T17:59:31.693Z"}
info: User Already exists {"timestamp":"2023-08-12T17:59:31.694Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:59:31.696Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:31.699Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:59:44.750Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:44.839Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:59:44.839Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:44.840Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:59:44.841Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:59:44.854Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:59:44.855Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:59:44.895Z"}
debug: Executing (35af5610-5656-48ff-be79-57e6d004943b): START TRANSACTION; {"timestamp":"2023-08-12T17:59:44.896Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:59:44.897Z"}
debug: Executing (35af5610-5656-48ff-be79-57e6d004943b): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:59:44.903Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:44.904Z"}
debug: Executing (35af5610-5656-48ff-be79-57e6d004943b): COMMIT; {"timestamp":"2023-08-12T17:59:44.908Z"}
info: User Already exists {"timestamp":"2023-08-12T17:59:44.909Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:59:44.912Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:44.914Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:59:48.922Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:49.012Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:59:49.013Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:49.014Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:59:49.015Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:59:49.029Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:59:49.030Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:59:49.071Z"}
debug: Executing (11bc6a22-4c04-47d2-9834-7b5c404c3fa8): START TRANSACTION; {"timestamp":"2023-08-12T17:59:49.072Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:59:49.074Z"}
debug: Executing (11bc6a22-4c04-47d2-9834-7b5c404c3fa8): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:59:49.080Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:49.081Z"}
debug: Executing (11bc6a22-4c04-47d2-9834-7b5c404c3fa8): COMMIT; {"timestamp":"2023-08-12T17:59:49.085Z"}
info: User Already exists {"timestamp":"2023-08-12T17:59:49.086Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:59:49.088Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:49.090Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T17:59:59.458Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:59.548Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T17:59:59.549Z"}
info: ================================================================ {"timestamp":"2023-08-12T17:59:59.550Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T17:59:59.550Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T17:59:59.567Z"}
info: Redis store initialized {"timestamp":"2023-08-12T17:59:59.568Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T17:59:59.608Z"}
debug: Executing (874bf928-d3f0-4664-9248-96fee2504b4e): START TRANSACTION; {"timestamp":"2023-08-12T17:59:59.609Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T17:59:59.611Z"}
debug: Executing (874bf928-d3f0-4664-9248-96fee2504b4e): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T17:59:59.616Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:59.618Z"}
debug: Executing (874bf928-d3f0-4664-9248-96fee2504b4e): COMMIT; {"timestamp":"2023-08-12T17:59:59.622Z"}
info: User Already exists {"timestamp":"2023-08-12T17:59:59.623Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T17:59:59.625Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T17:59:59.627Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:00:02.753Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:02.855Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:00:02.856Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:02.856Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:00:02.857Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:00:02.871Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:00:02.872Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:00:02.913Z"}
debug: Executing (f89b4bed-75b1-474c-8fce-38e4e4b7bbf2): START TRANSACTION; {"timestamp":"2023-08-12T18:00:02.914Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:00:02.915Z"}
debug: Executing (f89b4bed-75b1-474c-8fce-38e4e4b7bbf2): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:00:02.921Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:02.922Z"}
debug: Executing (f89b4bed-75b1-474c-8fce-38e4e4b7bbf2): COMMIT; {"timestamp":"2023-08-12T18:00:02.926Z"}
info: User Already exists {"timestamp":"2023-08-12T18:00:02.927Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:00:02.930Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:02.933Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:00:06.951Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:07.050Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:00:07.051Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:07.052Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:00:07.052Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:00:07.066Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:00:07.067Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:00:07.111Z"}
debug: Executing (d960c47c-1f92-4b6f-af7a-96d83d014fbf): START TRANSACTION; {"timestamp":"2023-08-12T18:00:07.112Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:00:07.113Z"}
debug: Executing (d960c47c-1f92-4b6f-af7a-96d83d014fbf): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:00:07.119Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:07.120Z"}
debug: Executing (d960c47c-1f92-4b6f-af7a-96d83d014fbf): COMMIT; {"timestamp":"2023-08-12T18:00:07.125Z"}
info: User Already exists {"timestamp":"2023-08-12T18:00:07.126Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:00:07.129Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:07.131Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:00:09.915Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:10.004Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:00:10.004Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:10.005Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:00:10.005Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:00:10.019Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:00:10.020Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:00:10.066Z"}
debug: Executing (1fed8d93-324f-49e0-8569-5188658874d0): START TRANSACTION; {"timestamp":"2023-08-12T18:00:10.067Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:00:10.068Z"}
debug: Executing (1fed8d93-324f-49e0-8569-5188658874d0): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:00:10.074Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:10.075Z"}
debug: Executing (1fed8d93-324f-49e0-8569-5188658874d0): COMMIT; {"timestamp":"2023-08-12T18:00:10.081Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:00:10.085Z"}
info: User Already exists {"timestamp":"2023-08-12T18:00:10.085Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:10.087Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:00:30.776Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:30.868Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:00:30.868Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:30.869Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:00:30.870Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:00:30.888Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:00:30.889Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:00:30.949Z"}
debug: Executing (42e95377-4de5-4bf6-af4a-60cc1356bbb9): START TRANSACTION; {"timestamp":"2023-08-12T18:00:30.950Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:00:30.952Z"}
debug: Executing (42e95377-4de5-4bf6-af4a-60cc1356bbb9): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:00:30.958Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:30.960Z"}
debug: Executing (42e95377-4de5-4bf6-af4a-60cc1356bbb9): COMMIT; {"timestamp":"2023-08-12T18:00:30.965Z"}
info: User Already exists {"timestamp":"2023-08-12T18:00:30.966Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:00:30.971Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:30.974Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:00:31.659Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:31.751Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:00:31.752Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:31.752Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:00:31.753Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:00:31.768Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:00:31.768Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:00:31.811Z"}
debug: Executing (586c5e15-fbda-4d67-b03b-64346147e17f): START TRANSACTION; {"timestamp":"2023-08-12T18:00:31.812Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:00:31.813Z"}
debug: Executing (586c5e15-fbda-4d67-b03b-64346147e17f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:00:31.819Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:31.821Z"}
debug: Executing (586c5e15-fbda-4d67-b03b-64346147e17f): COMMIT; {"timestamp":"2023-08-12T18:00:31.825Z"}
info: User Already exists {"timestamp":"2023-08-12T18:00:31.826Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:00:31.830Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:31.832Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:00:40.029Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:40.123Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:00:40.124Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:40.124Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:00:40.125Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:00:40.139Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:00:40.140Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:00:40.190Z"}
debug: Executing (1c6d56e8-4516-48de-b325-d067ac61450e): START TRANSACTION; {"timestamp":"2023-08-12T18:00:40.190Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:00:40.192Z"}
debug: Executing (1c6d56e8-4516-48de-b325-d067ac61450e): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:00:40.197Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:40.199Z"}
debug: Executing (1c6d56e8-4516-48de-b325-d067ac61450e): COMMIT; {"timestamp":"2023-08-12T18:00:40.203Z"}
info: User Already exists {"timestamp":"2023-08-12T18:00:40.204Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:00:40.207Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:40.209Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:00:43.654Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:43.755Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:00:43.756Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:00:43.756Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:00:43.757Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:00:43.772Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:00:43.773Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:00:43.818Z"}
debug: Executing (41652bbf-d8a6-4600-a9ac-5487f7cac2bd): START TRANSACTION; {"timestamp":"2023-08-12T18:00:43.819Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:00:43.820Z"}
debug: Executing (41652bbf-d8a6-4600-a9ac-5487f7cac2bd): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:00:43.825Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:43.826Z"}
debug: Executing (41652bbf-d8a6-4600-a9ac-5487f7cac2bd): COMMIT; {"timestamp":"2023-08-12T18:00:43.832Z"}
info: User Already exists {"timestamp":"2023-08-12T18:00:43.833Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:00:43.835Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:00:43.838Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:01:05.236Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:01:05.329Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:01:05.329Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:01:05.330Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:01:05.331Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:01:05.349Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:01:05.349Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:01:05.394Z"}
debug: Executing (36c2ceb7-adff-42cf-a69a-a32485694270): START TRANSACTION; {"timestamp":"2023-08-12T18:01:05.397Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:01:05.398Z"}
debug: Executing (36c2ceb7-adff-42cf-a69a-a32485694270): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:01:05.405Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:05.406Z"}
debug: Executing (36c2ceb7-adff-42cf-a69a-a32485694270): COMMIT; {"timestamp":"2023-08-12T18:01:05.411Z"}
info: User Already exists {"timestamp":"2023-08-12T18:01:05.412Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:01:05.415Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:05.418Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'studnets' {"timestamp":"2023-08-12T18:01:05.421Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:01:05.424Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:05.436Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:01:16.032Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:01:16.127Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:01:16.128Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:01:16.128Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:01:16.129Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:01:16.141Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:01:16.142Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:01:16.189Z"}
debug: Executing (68473edb-bbde-4323-84ac-549f61fe8d8b): START TRANSACTION; {"timestamp":"2023-08-12T18:01:16.189Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:01:16.190Z"}
debug: Executing (68473edb-bbde-4323-84ac-549f61fe8d8b): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:01:16.195Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:16.199Z"}
debug: Executing (68473edb-bbde-4323-84ac-549f61fe8d8b): COMMIT; {"timestamp":"2023-08-12T18:01:16.201Z"}
info: User Already exists {"timestamp":"2023-08-12T18:01:16.202Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:01:16.206Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:16.209Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'studnets' {"timestamp":"2023-08-12T18:01:16.213Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:16.215Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:01:48.823Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:01:48.916Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:01:48.917Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:01:48.918Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:01:48.918Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:01:48.934Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:01:48.935Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:01:48.974Z"}
debug: Executing (becb85ca-9f90-4600-a768-82425aa410e7): START TRANSACTION; {"timestamp":"2023-08-12T18:01:48.975Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users' {"timestamp":"2023-08-12T18:01:48.976Z"}
debug: Executing (becb85ca-9f90-4600-a768-82425aa410e7): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:01:48.981Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:48.982Z"}
debug: Executing (becb85ca-9f90-4600-a768-82425aa410e7): COMMIT; {"timestamp":"2023-08-12T18:01:48.986Z"}
info: User Already exists {"timestamp":"2023-08-12T18:01:48.987Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'studnets' {"timestamp":"2023-08-12T18:01:48.990Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:48.992Z"}
debug: Executing (default): SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'class' {"timestamp":"2023-08-12T18:01:48.996Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:01:48.998Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:02:16.219Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:02:16.311Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:02:16.312Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:02:16.312Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:02:16.313Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:02:16.327Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:02:16.328Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:02:16.371Z"}
debug: Executing (db266720-27f3-4599-9e08-9ffcbc3cb878): START TRANSACTION; {"timestamp":"2023-08-12T18:02:16.372Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:02:16.373Z"}
debug: Executing (db266720-27f3-4599-9e08-9ffcbc3cb878): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:02:16.378Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:02:16.380Z"}
debug: Executing (db266720-27f3-4599-9e08-9ffcbc3cb878): COMMIT; {"timestamp":"2023-08-12T18:02:16.384Z"}
info: User Already exists {"timestamp":"2023-08-12T18:02:16.385Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:02:16.386Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:02:16.391Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:02:16.409Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:02:16.416Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:02:16.422Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:02:16.423Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:02:16.425Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:02:16.426Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:02:16.429Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:02:16.439Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:02:16.445Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:02:16.446Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:02:16.454Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:02:16.458Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "studnetId" INTEGER REFERENCES "studnets" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:02:16.460Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:02:16.467Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:02:37.994Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:02:38.094Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:02:38.095Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:02:38.096Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:02:38.096Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:02:38.112Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:02:38.113Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:02:38.153Z"}
debug: Executing (071554d0-587e-44a5-b86a-e575e24457d1): START TRANSACTION; {"timestamp":"2023-08-12T18:02:38.154Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:02:38.156Z"}
debug: Executing (071554d0-587e-44a5-b86a-e575e24457d1): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:02:38.162Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:02:38.163Z"}
debug: Executing (071554d0-587e-44a5-b86a-e575e24457d1): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_83339856a4134094af8e2c26050df33c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:02:38.167 +00:00','2023-08-12 18:02:38.167 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_83339856a4134094af8e2c26050df33c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:02:38.171Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:02:38.172Z"}
debug: Executing (071554d0-587e-44a5-b86a-e575e24457d1): COMMIT; {"timestamp":"2023-08-12T18:02:38.176Z"}
info: User Already exists {"timestamp":"2023-08-12T18:02:38.178Z"}
info: User Created {"timestamp":"2023-08-12T18:02:38.178Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:02:38.181Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:02:38.197Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:02:38.204Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:02:38.211Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:02:38.212Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:02:38.213Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:02:38.215Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:02:38.217Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:02:38.227Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:02:38.233Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:02:38.235Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:02:38.240Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:02:38.244Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:02:38.246Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:02:38.256Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:03:05.947Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:03:06.041Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:03:06.041Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:03:06.042Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:03:06.042Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:03:06.056Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:03:06.057Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:03:06.096Z"}
debug: Executing (41b908ce-696b-4d13-b3d6-6c6c185009a4): START TRANSACTION; {"timestamp":"2023-08-12T18:03:06.098Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:03:06.099Z"}
debug: Executing (41b908ce-696b-4d13-b3d6-6c6c185009a4): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:03:06.105Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:03:06.107Z"}
debug: Executing (41b908ce-696b-4d13-b3d6-6c6c185009a4): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_a2d1e966b3fc4aa183cfaaff74731648$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:03:06.110 +00:00','2023-08-12 18:03:06.110 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_a2d1e966b3fc4aa183cfaaff74731648$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:03:06.114Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:03:06.115Z"}
debug: Executing (41b908ce-696b-4d13-b3d6-6c6c185009a4): COMMIT; {"timestamp":"2023-08-12T18:03:06.119Z"}
info: User Already exists {"timestamp":"2023-08-12T18:03:06.121Z"}
info: User Created {"timestamp":"2023-08-12T18:03:06.121Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:03:06.125Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:03:06.140Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:03:06.146Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:03:06.153Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:03:06.154Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:03:06.156Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:03:06.157Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:03:06.159Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:03:06.168Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:03:06.174Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:03:06.175Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:03:06.181Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:03:06.184Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:03:06.186Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:03:06.195Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:03:19.545Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:03:19.660Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:03:19.661Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:03:19.662Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:03:19.662Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:03:19.677Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:03:19.677Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:03:19.719Z"}
debug: Executing (2318345b-dddc-48e8-801d-8157cf45d46e): START TRANSACTION; {"timestamp":"2023-08-12T18:03:19.720Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:03:19.721Z"}
debug: Executing (2318345b-dddc-48e8-801d-8157cf45d46e): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:03:19.726Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:03:19.729Z"}
debug: Executing (2318345b-dddc-48e8-801d-8157cf45d46e): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_21aac432c4a1490aba609834fe4f72dc$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:03:19.732 +00:00','2023-08-12 18:03:19.732 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_21aac432c4a1490aba609834fe4f72dc$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:03:19.736Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:03:19.737Z"}
debug: Executing (2318345b-dddc-48e8-801d-8157cf45d46e): COMMIT; {"timestamp":"2023-08-12T18:03:19.741Z"}
info: User Already exists {"timestamp":"2023-08-12T18:03:19.743Z"}
info: User Created {"timestamp":"2023-08-12T18:03:19.744Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:03:19.747Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:03:19.763Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:03:19.769Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:03:19.776Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:03:19.777Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:03:19.778Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:03:19.779Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:03:19.781Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:03:19.791Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:03:19.797Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:03:19.798Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:03:19.804Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:03:19.807Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:03:19.809Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:03:19.818Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:05:13.532Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:05:13.624Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:05:13.625Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:05:13.625Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:05:13.626Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:05:13.641Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:05:13.641Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:05:13.682Z"}
debug: Executing (bd75bbca-944f-4fa5-ba83-040d053c9fb1): START TRANSACTION; {"timestamp":"2023-08-12T18:05:13.683Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:13.683Z"}
debug: Executing (bd75bbca-944f-4fa5-ba83-040d053c9fb1): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:05:13.689Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:13.690Z"}
debug: Executing (bd75bbca-944f-4fa5-ba83-040d053c9fb1): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_06d89907c4d04c5cbe6fa7d61a2b534d$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:05:13.694 +00:00','2023-08-12 18:05:13.694 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_06d89907c4d04c5cbe6fa7d61a2b534d$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:05:13.698Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:13.699Z"}
debug: Executing (bd75bbca-944f-4fa5-ba83-040d053c9fb1): COMMIT; {"timestamp":"2023-08-12T18:05:13.703Z"}
info: User Already exists {"timestamp":"2023-08-12T18:05:13.705Z"}
info: User Created {"timestamp":"2023-08-12T18:05:13.706Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:13.709Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:13.725Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:13.731Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:13.738Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:13.739Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:13.740Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:13.741Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:13.744Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:13.753Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:13.759Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:13.760Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:13.766Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:13.769Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:13.771Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:13.780Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:05:21.521Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:05:21.613Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:05:21.613Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:05:21.614Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:05:21.615Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:05:21.629Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:05:21.630Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:05:21.671Z"}
debug: Executing (2def096b-48d5-4db7-a5f4-a730f3ec4f6b): START TRANSACTION; {"timestamp":"2023-08-12T18:05:21.671Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:21.672Z"}
debug: Executing (2def096b-48d5-4db7-a5f4-a730f3ec4f6b): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:05:21.677Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:21.679Z"}
debug: Executing (2def096b-48d5-4db7-a5f4-a730f3ec4f6b): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_a4d2c362a1a94466a37368ad35ec6b3c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:05:21.683 +00:00','2023-08-12 18:05:21.683 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_a4d2c362a1a94466a37368ad35ec6b3c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:05:21.687Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:21.688Z"}
debug: Executing (2def096b-48d5-4db7-a5f4-a730f3ec4f6b): COMMIT; {"timestamp":"2023-08-12T18:05:21.692Z"}
info: User Already exists {"timestamp":"2023-08-12T18:05:21.694Z"}
info: User Created {"timestamp":"2023-08-12T18:05:21.694Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:21.698Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:21.714Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:21.721Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:21.727Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:21.729Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:21.730Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:21.732Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:21.734Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:21.743Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:21.749Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:21.751Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:21.756Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:21.759Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:21.761Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:21.770Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:05:53.342Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:05:53.433Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:05:53.433Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:05:53.434Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:05:53.435Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:05:53.450Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:05:53.450Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:05:53.504Z"}
debug: Executing (fa4bd0e3-3bc6-41b2-aae4-ae8168222b60): START TRANSACTION; {"timestamp":"2023-08-12T18:05:53.505Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:53.506Z"}
debug: Executing (fa4bd0e3-3bc6-41b2-aae4-ae8168222b60): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:05:53.511Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:53.513Z"}
debug: Executing (fa4bd0e3-3bc6-41b2-aae4-ae8168222b60): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_7b0daac0756243d09a3385a4bd066f6c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:05:53.518 +00:00','2023-08-12 18:05:53.518 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_7b0daac0756243d09a3385a4bd066f6c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:05:53.522Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:53.523Z"}
debug: Executing (fa4bd0e3-3bc6-41b2-aae4-ae8168222b60): COMMIT; {"timestamp":"2023-08-12T18:05:53.528Z"}
info: User Already exists {"timestamp":"2023-08-12T18:05:53.530Z"}
info: User Created {"timestamp":"2023-08-12T18:05:53.530Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:53.533Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:53.548Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:05:53.555Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:53.561Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:53.563Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:53.564Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:05:53.566Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:53.568Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:53.577Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:05:53.583Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:53.585Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:53.590Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:05:53.594Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:05:53.595Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:05:53.605Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:06:12.468Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:06:12.565Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:06:12.566Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:06:12.567Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:06:12.567Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:06:12.583Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:06:12.584Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:06:12.632Z"}
debug: Executing (dc250a07-0abb-4064-a205-d81bec057b15): START TRANSACTION; {"timestamp":"2023-08-12T18:06:12.633Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:12.635Z"}
debug: Executing (dc250a07-0abb-4064-a205-d81bec057b15): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:06:12.642Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:12.647Z"}
debug: Executing (dc250a07-0abb-4064-a205-d81bec057b15): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_756d952e4a904472b2a0cd82a86d815c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:06:12.648 +00:00','2023-08-12 18:06:12.648 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_756d952e4a904472b2a0cd82a86d815c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:06:12.653Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:12.654Z"}
debug: Executing (dc250a07-0abb-4064-a205-d81bec057b15): COMMIT; {"timestamp":"2023-08-12T18:06:12.659Z"}
info: User Already exists {"timestamp":"2023-08-12T18:06:12.662Z"}
info: User Created {"timestamp":"2023-08-12T18:06:12.662Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:12.666Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:12.685Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:12.691Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:12.699Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:12.700Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:12.702Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:12.704Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:12.706Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:12.718Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:12.728Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:12.730Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:12.736Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:12.740Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:12.742Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:12.753Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:06:39.316Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:06:39.408Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:06:39.408Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:06:39.409Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:06:39.410Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:06:39.425Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:06:39.426Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:06:39.475Z"}
debug: Executing (0e920066-96c1-4df5-9b64-834ddc760e75): START TRANSACTION; {"timestamp":"2023-08-12T18:06:39.476Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:39.477Z"}
debug: Executing (0e920066-96c1-4df5-9b64-834ddc760e75): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:06:39.483Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:39.485Z"}
debug: Executing (0e920066-96c1-4df5-9b64-834ddc760e75): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_9cde87ef6df64869ba5d66e70c6f20b6$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:06:39.487 +00:00','2023-08-12 18:06:39.487 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_9cde87ef6df64869ba5d66e70c6f20b6$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:06:39.492Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:39.493Z"}
debug: Executing (0e920066-96c1-4df5-9b64-834ddc760e75): COMMIT; {"timestamp":"2023-08-12T18:06:39.497Z"}
info: User Already exists {"timestamp":"2023-08-12T18:06:39.498Z"}
info: User Created {"timestamp":"2023-08-12T18:06:39.499Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:39.502Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:39.517Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:39.524Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:39.530Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:39.531Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:39.532Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:39.534Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:39.536Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:39.545Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:39.551Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:39.552Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:39.558Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:39.562Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:39.563Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:39.573Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:06:50.289Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:06:50.388Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:06:50.388Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:06:50.389Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:06:50.389Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:06:50.408Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:06:50.410Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:06:50.460Z"}
debug: Executing (80429ebb-356e-4fe3-9ef2-f14322e8e0a4): START TRANSACTION; {"timestamp":"2023-08-12T18:06:50.461Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:50.462Z"}
debug: Executing (80429ebb-356e-4fe3-9ef2-f14322e8e0a4): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:06:50.470Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:50.473Z"}
debug: Executing (80429ebb-356e-4fe3-9ef2-f14322e8e0a4): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_d7297beed8f3457b8f3c94f868e72907$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:06:50.477 +00:00','2023-08-12 18:06:50.477 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_d7297beed8f3457b8f3c94f868e72907$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:06:50.482Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:50.483Z"}
debug: Executing (80429ebb-356e-4fe3-9ef2-f14322e8e0a4): COMMIT; {"timestamp":"2023-08-12T18:06:50.487Z"}
info: User Already exists {"timestamp":"2023-08-12T18:06:50.490Z"}
info: User Created {"timestamp":"2023-08-12T18:06:50.491Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:50.494Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:50.511Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:06:50.518Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:50.525Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:50.527Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:50.528Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:06:50.530Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:50.533Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:50.544Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:06:50.550Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:50.551Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:50.557Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:06:50.562Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:06:50.563Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:06:50.574Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:07:33.893Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:07:33.994Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:07:33.995Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:07:33.996Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:07:33.996Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:07:34.011Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:07:34.012Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:07:34.061Z"}
debug: Executing (0711add4-d6a5-495f-9b2d-f09950c77312): START TRANSACTION; {"timestamp":"2023-08-12T18:07:34.062Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:07:34.063Z"}
debug: Executing (0711add4-d6a5-495f-9b2d-f09950c77312): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:07:34.068Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:07:34.069Z"}
debug: Executing (0711add4-d6a5-495f-9b2d-f09950c77312): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_6c2f7df873a34ebda88e56df3da7218f$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:07:34.074 +00:00','2023-08-12 18:07:34.074 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_6c2f7df873a34ebda88e56df3da7218f$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:07:34.078Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:07:34.080Z"}
debug: Executing (0711add4-d6a5-495f-9b2d-f09950c77312): COMMIT; {"timestamp":"2023-08-12T18:07:34.084Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:07:34.085Z"}
info: User Already exists {"timestamp":"2023-08-12T18:07:34.086Z"}
info: User Created {"timestamp":"2023-08-12T18:07:34.087Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:07:34.090Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:07:34.107Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'studnets' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:07:34.114Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:07:34.121Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:07:34.128Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:07:34.130Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:07:34.131Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:07:34.132Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:07:34.134Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:07:34.137Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:07:34.148Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:07:34.154Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:07:34.156Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:07:34.163Z"}
debug: Executing (default): DROP TABLE IF EXISTS "studnets" CASCADE; {"timestamp":"2023-08-12T18:07:34.166Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "studnets" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:07:34.168Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'studnets' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:07:34.178Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:07:34.181Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:07:34.182Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:07:34.190Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:07:49.952Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:07:50.065Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:07:50.066Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:07:50.066Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:07:50.067Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:07:50.082Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:07:50.082Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:07:50.150Z"}
debug: Executing (3120ea7f-9033-4a02-911c-0d263e94e2e9): START TRANSACTION; {"timestamp":"2023-08-12T18:07:50.151Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:07:50.153Z"}
debug: Executing (3120ea7f-9033-4a02-911c-0d263e94e2e9): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:07:50.160Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:07:50.162Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:07:50.163Z"}
debug: Executing (3120ea7f-9033-4a02-911c-0d263e94e2e9): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_dd17f329031443459d3c7dadd28e08e5$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:07:50.166 +00:00','2023-08-12 18:07:50.166 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_dd17f329031443459d3c7dadd28e08e5$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:07:50.171Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:07:50.172Z"}
debug: Executing (3120ea7f-9033-4a02-911c-0d263e94e2e9): COMMIT; {"timestamp":"2023-08-12T18:07:50.178Z"}
info: User Already exists {"timestamp":"2023-08-12T18:07:50.180Z"}
info: User Created {"timestamp":"2023-08-12T18:07:50.180Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:07:50.183Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:07:50.200Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:07:50.207Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:07:50.213Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:07:50.220Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:07:50.222Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:07:50.224Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:07:50.225Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:07:50.227Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:07:50.230Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:07:50.239Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:07:50.245Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:07:50.246Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:07:50.252Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:07:50.255Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:07:50.257Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:07:50.266Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:07:50.269Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:07:50.270Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:07:50.279Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:09:37.526Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:09:37.643Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:09:37.644Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:09:37.645Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:09:37.646Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:09:37.664Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:09:37.665Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:09:37.726Z"}
debug: Executing (4f0e2a8b-4e62-46ba-b665-5b2a97f76fc8): START TRANSACTION; {"timestamp":"2023-08-12T18:09:37.727Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:09:37.728Z"}
debug: Executing (4f0e2a8b-4e62-46ba-b665-5b2a97f76fc8): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:09:37.736Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:09:37.738Z"}
debug: Executing (4f0e2a8b-4e62-46ba-b665-5b2a97f76fc8): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_81310349d6ef45d38653c3940bc56112$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:09:37.743 +00:00','2023-08-12 18:09:37.743 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_81310349d6ef45d38653c3940bc56112$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:09:37.748Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:09:37.750Z"}
debug: Executing (4f0e2a8b-4e62-46ba-b665-5b2a97f76fc8): COMMIT; {"timestamp":"2023-08-12T18:09:37.756Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:09:37.757Z"}
info: User Already exists {"timestamp":"2023-08-12T18:09:37.758Z"}
info: User Created {"timestamp":"2023-08-12T18:09:37.759Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:09:37.764Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:09:37.787Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:09:37.796Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:09:37.806Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:09:37.815Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:09:37.818Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:09:37.819Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:09:37.821Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:09:37.823Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:09:37.827Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:09:37.840Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:09:37.848Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:09:37.850Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:09:37.861Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:09:37.865Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "voucherId" INTEGER REFERENCES "voucher" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:09:37.867Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:09:37.877Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:09:37.880Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "voucherId" INTEGER REFERENCES "voucher" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:09:37.883Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:09:37.897Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:09:45.307Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:09:45.415Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:09:45.416Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:09:45.416Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:09:45.417Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:09:45.432Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:09:45.433Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:09:45.476Z"}
debug: Executing (7b435282-e8d2-44ba-a990-fdb829d56d1d): START TRANSACTION; {"timestamp":"2023-08-12T18:09:45.477Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:09:45.477Z"}
debug: Executing (7b435282-e8d2-44ba-a990-fdb829d56d1d): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:09:45.483Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:09:45.486Z"}
debug: Executing (7b435282-e8d2-44ba-a990-fdb829d56d1d): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_6521dae83870473585fffa6617defc76$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:09:45.488 +00:00','2023-08-12 18:09:45.488 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_6521dae83870473585fffa6617defc76$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:09:45.492Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:09:45.493Z"}
debug: Executing (7b435282-e8d2-44ba-a990-fdb829d56d1d): COMMIT; {"timestamp":"2023-08-12T18:09:45.498Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:09:45.498Z"}
info: User Already exists {"timestamp":"2023-08-12T18:09:45.499Z"}
info: User Created {"timestamp":"2023-08-12T18:09:45.500Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:09:45.503Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:09:45.519Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:09:45.526Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:09:45.532Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:09:45.540Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:09:45.541Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:09:45.542Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:09:45.543Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:09:45.544Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:09:45.547Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:09:45.556Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:09:45.563Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:09:45.564Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:09:45.573Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:09:45.576Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "voucherId" INTEGER REFERENCES "voucher" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:09:45.577Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:09:45.584Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:09:45.587Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "voucherId" INTEGER REFERENCES "voucher" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:09:45.590Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:09:45.606Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:10:22.426Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:10:22.529Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:10:22.530Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:10:22.531Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:10:22.532Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:10:22.546Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:10:22.547Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:10:22.591Z"}
debug: Executing (a501954a-3dae-4afa-95e5-ab45ce4181d6): START TRANSACTION; {"timestamp":"2023-08-12T18:10:22.592Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:10:22.593Z"}
debug: Executing (a501954a-3dae-4afa-95e5-ab45ce4181d6): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:10:22.601Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:10:22.604Z"}
debug: Executing (a501954a-3dae-4afa-95e5-ab45ce4181d6): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_920e2d5a487a45e7ab8ea23da541e84f$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:10:22.608 +00:00','2023-08-12 18:10:22.608 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_920e2d5a487a45e7ab8ea23da541e84f$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:10:22.612Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:10:22.613Z"}
debug: Executing (a501954a-3dae-4afa-95e5-ab45ce4181d6): COMMIT; {"timestamp":"2023-08-12T18:10:22.619Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:10:22.621Z"}
info: User Already exists {"timestamp":"2023-08-12T18:10:22.622Z"}
info: User Created {"timestamp":"2023-08-12T18:10:22.623Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:10:22.626Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:10:22.643Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:10:22.652Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:10:22.659Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:10:22.669Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:10:22.670Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:10:22.671Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:10:22.672Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:10:22.674Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:10:22.677Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:10:22.688Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:10:22.694Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:10:22.695Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:10:22.701Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:10:22.705Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:10:22.706Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:10:22.717Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:10:22.720Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:10:22.721Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:10:22.731Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-12T18:10:23.813Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:10:23.911Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-12T18:10:23.912Z"}
info: ================================================================ {"timestamp":"2023-08-12T18:10:23.913Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-12T18:10:23.913Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-12T18:10:23.928Z"}
info: Redis store initialized {"timestamp":"2023-08-12T18:10:23.929Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-12T18:10:23.974Z"}
debug: Executing (6c9e7809-fade-459c-a103-31c008a9533d): START TRANSACTION; {"timestamp":"2023-08-12T18:10:23.975Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:10:23.976Z"}
debug: Executing (6c9e7809-fade-459c-a103-31c008a9533d): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-12T18:10:23.984Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:10:23.987Z"}
debug: Executing (6c9e7809-fade-459c-a103-31c008a9533d): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_4a76e7de25624dadbdc1d312d5e10a4f$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-12 18:10:23.990 +00:00','2023-08-12 18:10:23.990 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_4a76e7de25624dadbdc1d312d5e10a4f$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-12T18:10:23.994Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:10:23.995Z"}
debug: Executing (6c9e7809-fade-459c-a103-31c008a9533d): COMMIT; {"timestamp":"2023-08-12T18:10:24.000Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:10:24.000Z"}
info: User Already exists {"timestamp":"2023-08-12T18:10:24.002Z"}
info: User Created {"timestamp":"2023-08-12T18:10:24.002Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:10:24.006Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:10:24.020Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:10:24.028Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-12T18:10:24.037Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:10:24.047Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:10:24.050Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:10:24.052Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:10:24.053Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-12T18:10:24.055Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:10:24.057Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:10:24.068Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-12T18:10:24.075Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:10:24.076Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:10:24.083Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-12T18:10:24.087Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:10:24.088Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:10:24.098Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-12T18:10:24.102Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-12T18:10:24.103Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-12T18:10:24.113Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:28:40.999Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:28:41.246Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:28:41.247Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:28:41.248Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:28:41.248Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:28:41.263Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:28:41.264Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:28:41.306Z"}
debug: Executing (3c51ebf5-a277-4b50-89f6-cfd65ab1fd25): START TRANSACTION; {"timestamp":"2023-08-15T06:28:41.308Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:28:41.309Z"}
debug: Executing (3c51ebf5-a277-4b50-89f6-cfd65ab1fd25): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:28:41.313Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:28:41.317Z"}
debug: Executing (3c51ebf5-a277-4b50-89f6-cfd65ab1fd25): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_f648b008f12e481a8276ee126df049da$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:28:41.319 +00:00','2023-08-15 06:28:41.319 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_f648b008f12e481a8276ee126df049da$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:28:41.323Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:28:41.324Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:28:41.328Z"}
debug: Executing (3c51ebf5-a277-4b50-89f6-cfd65ab1fd25): COMMIT; {"timestamp":"2023-08-15T06:28:41.329Z"}
info: User Already exists {"timestamp":"2023-08-15T06:28:41.331Z"}
info: User Created {"timestamp":"2023-08-15T06:28:41.332Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:28:41.335Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:28:41.351Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:28:41.358Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:28:41.366Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:28:41.373Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:28:41.375Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:28:41.376Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:28:41.377Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:28:41.379Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:28:41.382Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:28:41.393Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:28:41.399Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:28:41.400Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:28:41.407Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:28:41.410Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:28:41.412Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:28:41.422Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:28:41.425Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:28:41.427Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:28:41.437Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:30:26.660Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:30:26.756Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:30:26.756Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:30:26.757Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:30:26.757Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:30:26.772Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:30:26.773Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:30:26.816Z"}
debug: Executing (550b4bde-4341-4278-847c-b8bbdac0d39d): START TRANSACTION; {"timestamp":"2023-08-15T06:30:26.819Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:30:26.820Z"}
debug: Executing (550b4bde-4341-4278-847c-b8bbdac0d39d): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:30:26.825Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:30:26.829Z"}
debug: Executing (550b4bde-4341-4278-847c-b8bbdac0d39d): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_f74b1597e50640b4ab2227190cfa9de2$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:30:26.831 +00:00','2023-08-15 06:30:26.831 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_f74b1597e50640b4ab2227190cfa9de2$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:30:26.835Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:30:26.836Z"}
debug: Executing (550b4bde-4341-4278-847c-b8bbdac0d39d): COMMIT; {"timestamp":"2023-08-15T06:30:26.840Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:30:26.841Z"}
info: User Already exists {"timestamp":"2023-08-15T06:30:26.842Z"}
info: User Created {"timestamp":"2023-08-15T06:30:26.842Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:30:26.846Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:30:26.862Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:30:26.868Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:30:26.875Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:30:26.881Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:30:26.883Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:30:26.884Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:30:26.885Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:30:26.886Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:30:26.889Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:30:26.898Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:30:26.904Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:30:26.905Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:30:26.910Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:30:26.913Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:30:26.915Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:30:26.924Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:30:26.927Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:30:26.928Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:30:26.938Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:30:41.691Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:30:41.806Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:30:41.807Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:30:41.808Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:30:41.808Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:30:41.824Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:30:41.825Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:30:41.872Z"}
debug: Executing (02052e5e-24f5-4744-9937-cdc7f5e1cba4): START TRANSACTION; {"timestamp":"2023-08-15T06:30:41.874Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:30:41.876Z"}
debug: Executing (02052e5e-24f5-4744-9937-cdc7f5e1cba4): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:30:41.882Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:30:41.887Z"}
debug: Executing (02052e5e-24f5-4744-9937-cdc7f5e1cba4): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_9b40a6a17a5349a399407bd9239d4a55$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:30:41.888 +00:00','2023-08-15 06:30:41.888 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_9b40a6a17a5349a399407bd9239d4a55$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:30:41.892Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:30:41.893Z"}
debug: Executing (02052e5e-24f5-4744-9937-cdc7f5e1cba4): COMMIT; {"timestamp":"2023-08-15T06:30:41.898Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:30:41.900Z"}
info: User Already exists {"timestamp":"2023-08-15T06:30:41.902Z"}
info: User Created {"timestamp":"2023-08-15T06:30:41.903Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:30:41.906Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:30:41.922Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:30:41.929Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:30:41.936Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:30:41.943Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:30:41.944Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:30:41.945Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:30:41.946Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:30:41.949Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:30:41.952Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:30:41.961Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:30:41.967Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:30:41.969Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:30:41.975Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:30:41.978Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:30:41.980Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:30:41.991Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:30:41.993Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:30:41.995Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:30:42.006Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:31:14.072Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:31:14.171Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:31:14.172Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:31:14.173Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:31:14.173Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:31:14.190Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:31:14.191Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:31:14.255Z"}
debug: Executing (8f6ad7da-14db-4fc4-bd95-79892fbc1cbe): START TRANSACTION; {"timestamp":"2023-08-15T06:31:14.255Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:31:14.256Z"}
debug: Executing (8f6ad7da-14db-4fc4-bd95-79892fbc1cbe): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:31:14.262Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:31:14.267Z"}
debug: Executing (8f6ad7da-14db-4fc4-bd95-79892fbc1cbe): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_ac21b660eebd4204b6e5e51c8f03ee3c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:31:14.269 +00:00','2023-08-15 06:31:14.269 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_ac21b660eebd4204b6e5e51c8f03ee3c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:31:14.273Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:31:14.274Z"}
debug: Executing (8f6ad7da-14db-4fc4-bd95-79892fbc1cbe): COMMIT; {"timestamp":"2023-08-15T06:31:14.280Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:31:14.281Z"}
info: User Already exists {"timestamp":"2023-08-15T06:31:14.282Z"}
info: User Created {"timestamp":"2023-08-15T06:31:14.283Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:31:14.286Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:31:14.303Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:31:14.311Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:31:14.318Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:31:14.325Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:31:14.327Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:31:14.328Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:31:14.330Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:31:14.332Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:31:14.335Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:31:14.345Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:31:14.351Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:31:14.352Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:31:14.358Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:31:14.361Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:31:14.364Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:31:14.373Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:31:14.376Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:31:14.378Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:31:14.389Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:32:01.123Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:32:01.272Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:32:01.273Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:32:01.273Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:32:01.274Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:32:01.289Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:32:01.290Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:32:01.343Z"}
debug: Executing (0dce0ef6-0adf-4908-9478-13c881de4e61): START TRANSACTION; {"timestamp":"2023-08-15T06:32:01.346Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:01.348Z"}
debug: Executing (0dce0ef6-0adf-4908-9478-13c881de4e61): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:32:01.355Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:01.357Z"}
debug: Executing (0dce0ef6-0adf-4908-9478-13c881de4e61): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_507cdced8d2f41c58072b89bbcd8d8df$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:32:01.363 +00:00','2023-08-15 06:32:01.363 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_507cdced8d2f41c58072b89bbcd8d8df$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:32:01.367Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:01.368Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:01.372Z"}
debug: Executing (0dce0ef6-0adf-4908-9478-13c881de4e61): COMMIT; {"timestamp":"2023-08-15T06:32:01.373Z"}
info: User Already exists {"timestamp":"2023-08-15T06:32:01.375Z"}
info: User Created {"timestamp":"2023-08-15T06:32:01.376Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:01.380Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:01.397Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:01.404Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:01.411Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:01.418Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:01.419Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:01.420Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:01.421Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:01.423Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:01.425Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:01.436Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:01.441Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:01.443Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:01.449Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:01.452Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:01.454Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:01.464Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:01.467Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:01.468Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:01.480Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:32:16.456Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:32:16.561Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:32:16.562Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:32:16.563Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:32:16.563Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:32:16.578Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:32:16.579Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:32:16.622Z"}
debug: Executing (1dfdc603-6d5e-4cd3-8594-b8ba42cc0469): START TRANSACTION; {"timestamp":"2023-08-15T06:32:16.622Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:16.623Z"}
debug: Executing (1dfdc603-6d5e-4cd3-8594-b8ba42cc0469): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:32:16.629Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:16.633Z"}
debug: Executing (1dfdc603-6d5e-4cd3-8594-b8ba42cc0469): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e21bed0719e14c84af7f1a79b8a84420$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:32:16.635 +00:00','2023-08-15 06:32:16.635 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e21bed0719e14c84af7f1a79b8a84420$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:32:16.639Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:16.640Z"}
debug: Executing (1dfdc603-6d5e-4cd3-8594-b8ba42cc0469): COMMIT; {"timestamp":"2023-08-15T06:32:16.645Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:16.645Z"}
info: User Already exists {"timestamp":"2023-08-15T06:32:16.646Z"}
info: User Created {"timestamp":"2023-08-15T06:32:16.647Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:16.650Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:16.666Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:16.673Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:16.679Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:16.686Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:16.688Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:16.689Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:16.690Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:16.691Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:16.695Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:16.704Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:16.710Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:16.711Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:16.717Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:16.720Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:16.721Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:16.731Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:16.733Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:16.734Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:16.744Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:32:25.979Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:32:26.076Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:32:26.077Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:32:26.078Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:32:26.078Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:32:26.094Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:32:26.095Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:32:26.138Z"}
debug: Executing (8bdb226e-23e9-4e96-90f9-477fdc419173): START TRANSACTION; {"timestamp":"2023-08-15T06:32:26.139Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:26.140Z"}
debug: Executing (8bdb226e-23e9-4e96-90f9-477fdc419173): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:32:26.146Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:26.149Z"}
debug: Executing (8bdb226e-23e9-4e96-90f9-477fdc419173): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_b2f3592d55b045c59657dea5ea6723a0$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:32:26.151 +00:00','2023-08-15 06:32:26.151 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_b2f3592d55b045c59657dea5ea6723a0$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:32:26.155Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:26.156Z"}
debug: Executing (8bdb226e-23e9-4e96-90f9-477fdc419173): COMMIT; {"timestamp":"2023-08-15T06:32:26.161Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:26.162Z"}
info: User Already exists {"timestamp":"2023-08-15T06:32:26.163Z"}
info: User Created {"timestamp":"2023-08-15T06:32:26.163Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:26.167Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:26.183Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:26.190Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:32:26.197Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:26.204Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:26.205Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:26.206Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:26.207Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:32:26.209Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:26.212Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:26.222Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:32:26.228Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:26.229Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:26.235Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:32:26.238Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:26.239Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:26.249Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:32:26.251Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:32:26.252Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:32:26.263Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:33:19.535Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:33:19.634Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:33:19.635Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:33:19.636Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:33:19.636Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:33:19.650Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:33:19.651Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:33:19.694Z"}
debug: Executing (75e129d6-580a-43b3-bad0-bd339b27c2d0): START TRANSACTION; {"timestamp":"2023-08-15T06:33:19.695Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:33:19.696Z"}
debug: Executing (75e129d6-580a-43b3-bad0-bd339b27c2d0): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:33:19.701Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:33:19.706Z"}
debug: Executing (75e129d6-580a-43b3-bad0-bd339b27c2d0): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_9234beb86ee743adaf2529a92162bfef$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:33:19.708 +00:00','2023-08-15 06:33:19.708 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_9234beb86ee743adaf2529a92162bfef$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:33:19.713Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:33:19.714Z"}
debug: Executing (75e129d6-580a-43b3-bad0-bd339b27c2d0): COMMIT; {"timestamp":"2023-08-15T06:33:19.719Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:33:19.720Z"}
info: User Already exists {"timestamp":"2023-08-15T06:33:19.721Z"}
info: User Created {"timestamp":"2023-08-15T06:33:19.722Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:33:19.726Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:33:19.742Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:33:19.749Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:33:19.756Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:33:19.763Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:33:19.764Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:33:19.765Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:33:19.766Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:33:19.768Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:33:19.770Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:33:19.781Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:33:19.786Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:33:19.787Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:33:19.794Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:33:19.797Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:33:19.798Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:33:19.809Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:33:19.811Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:33:19.813Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:33:19.823Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:33:35.411Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:33:35.528Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:33:35.528Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:33:35.529Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:33:35.529Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:33:35.547Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:33:35.548Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:33:35.600Z"}
debug: Executing (f81ec917-6479-4745-b5f9-715f33801da3): START TRANSACTION; {"timestamp":"2023-08-15T06:33:35.601Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:33:35.602Z"}
debug: Executing (f81ec917-6479-4745-b5f9-715f33801da3): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:33:35.609Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:33:35.613Z"}
debug: Executing (f81ec917-6479-4745-b5f9-715f33801da3): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_30882267cb9a49089083ee115cd7538f$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:33:35.616 +00:00','2023-08-15 06:33:35.616 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_30882267cb9a49089083ee115cd7538f$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:33:35.621Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:33:35.623Z"}
debug: Executing (f81ec917-6479-4745-b5f9-715f33801da3): COMMIT; {"timestamp":"2023-08-15T06:33:35.629Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:33:35.630Z"}
info: User Already exists {"timestamp":"2023-08-15T06:33:35.633Z"}
info: User Created {"timestamp":"2023-08-15T06:33:35.633Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:33:35.641Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:33:35.663Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:33:35.669Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:33:35.676Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:33:35.683Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:33:35.684Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:33:35.685Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:33:35.686Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:33:35.688Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:33:35.691Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:33:35.701Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:33:35.707Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:33:35.708Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:33:35.714Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:33:35.717Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:33:35.718Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:33:35.729Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:33:35.731Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:33:35.733Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:33:35.744Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:35:35.073Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:35:35.172Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:35:35.173Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:35:35.173Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:35:35.174Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:35:35.190Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:35:35.191Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:35:35.231Z"}
debug: Executing (313602b2-b384-459b-9761-71420a79307f): START TRANSACTION; {"timestamp":"2023-08-15T06:35:35.232Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:35:35.233Z"}
debug: Executing (313602b2-b384-459b-9761-71420a79307f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:35:35.239Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:35:35.242Z"}
debug: Executing (313602b2-b384-459b-9761-71420a79307f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_09b72d5c02184ae9bc1903a9db285042$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:35:35.244 +00:00','2023-08-15 06:35:35.244 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_09b72d5c02184ae9bc1903a9db285042$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:35:35.248Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:35:35.249Z"}
debug: Executing (313602b2-b384-459b-9761-71420a79307f): COMMIT; {"timestamp":"2023-08-15T06:35:35.254Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:35:35.254Z"}
info: User Already exists {"timestamp":"2023-08-15T06:35:35.255Z"}
info: User Created {"timestamp":"2023-08-15T06:35:35.256Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:35:35.259Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:35:35.275Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:35:35.282Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:35:35.288Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:35:35.295Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:35:35.296Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:35:35.297Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:35:35.298Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:35:35.299Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:35:35.302Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:35:35.311Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:35:35.317Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:35:35.319Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:35:35.324Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:35:35.327Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:35:35.329Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:35:35.338Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:35:35.341Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:35:35.342Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:35:35.352Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:36:00.545Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:36:00.651Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:36:00.651Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:36:00.652Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:36:00.652Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:36:00.667Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:36:00.668Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:36:00.721Z"}
debug: Executing (0e8fde9b-127d-4590-bb51-e97fe36c2310): START TRANSACTION; {"timestamp":"2023-08-15T06:36:00.722Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:36:00.723Z"}
debug: Executing (0e8fde9b-127d-4590-bb51-e97fe36c2310): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:36:00.728Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:36:00.732Z"}
debug: Executing (0e8fde9b-127d-4590-bb51-e97fe36c2310): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_1b65c70e3157465c8204b3ecbdaafbf0$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:36:00.734 +00:00','2023-08-15 06:36:00.734 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_1b65c70e3157465c8204b3ecbdaafbf0$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:36:00.738Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:36:00.740Z"}
debug: Executing (0e8fde9b-127d-4590-bb51-e97fe36c2310): COMMIT; {"timestamp":"2023-08-15T06:36:00.744Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:36:00.745Z"}
info: User Already exists {"timestamp":"2023-08-15T06:36:00.746Z"}
info: User Created {"timestamp":"2023-08-15T06:36:00.747Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:36:00.751Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:36:00.770Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:36:00.777Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:36:00.784Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:36:00.791Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:36:00.793Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:36:00.794Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:36:00.795Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:36:00.796Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:36:00.798Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:36:00.809Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:36:00.815Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:36:00.816Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:36:00.822Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:36:00.825Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:36:00.827Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:36:00.836Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:36:00.839Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:36:00.841Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:36:00.851Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:36:48.849Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:36:48.955Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:36:48.955Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:36:48.956Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:36:48.956Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:36:48.972Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:36:48.973Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:36:49.034Z"}
debug: Executing (6a2928b0-c31c-4939-a897-e94335efa382): START TRANSACTION; {"timestamp":"2023-08-15T06:36:49.036Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:36:49.037Z"}
debug: Executing (6a2928b0-c31c-4939-a897-e94335efa382): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:36:49.045Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:36:49.052Z"}
debug: Executing (6a2928b0-c31c-4939-a897-e94335efa382): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_0025f3817e324d3fa6ab69d0d9a04ec3$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:36:49.055 +00:00','2023-08-15 06:36:49.055 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_0025f3817e324d3fa6ab69d0d9a04ec3$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:36:49.062Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:36:49.063Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:36:49.069Z"}
debug: Executing (6a2928b0-c31c-4939-a897-e94335efa382): COMMIT; {"timestamp":"2023-08-15T06:36:49.072Z"}
info: User Already exists {"timestamp":"2023-08-15T06:36:49.074Z"}
info: User Created {"timestamp":"2023-08-15T06:36:49.075Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:36:49.080Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:36:49.099Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:36:49.107Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:36:49.115Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:36:49.124Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:36:49.125Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:36:49.127Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:36:49.128Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:36:49.130Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:36:49.135Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:36:49.148Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:36:49.155Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:36:49.156Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:36:49.162Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:36:49.166Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:36:49.168Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:36:49.177Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:36:49.180Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:36:49.182Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:36:49.193Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:40:52.812Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:40:52.911Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:40:52.912Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:40:52.912Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:40:52.913Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:40:52.928Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:40:52.929Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:40:52.973Z"}
debug: Executing (1b2eb075-b5c6-49f0-b62a-6c0833594fa1): START TRANSACTION; {"timestamp":"2023-08-15T06:40:52.974Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:40:52.975Z"}
debug: Executing (1b2eb075-b5c6-49f0-b62a-6c0833594fa1): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:40:52.980Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:40:52.984Z"}
debug: Executing (1b2eb075-b5c6-49f0-b62a-6c0833594fa1): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_31231eb908c2473ab0e3191b353120b0$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:40:52.987 +00:00','2023-08-15 06:40:52.987 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_31231eb908c2473ab0e3191b353120b0$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:40:52.992Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:40:52.993Z"}
debug: Executing (1b2eb075-b5c6-49f0-b62a-6c0833594fa1): COMMIT; {"timestamp":"2023-08-15T06:40:52.998Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:40:52.998Z"}
info: User Already exists {"timestamp":"2023-08-15T06:40:53.000Z"}
info: User Created {"timestamp":"2023-08-15T06:40:53.000Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:40:53.004Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:40:53.020Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:40:53.028Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:40:53.035Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:40:53.042Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:40:53.044Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:40:53.045Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:40:53.046Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:40:53.047Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:40:53.050Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:40:53.060Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:40:53.066Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:40:53.067Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:40:53.073Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:40:53.076Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:40:53.078Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:40:53.089Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:40:53.091Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:40:53.093Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:40:53.103Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:41:19.334Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:41:19.432Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:41:19.433Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:41:19.434Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:41:19.434Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:41:19.450Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:41:19.450Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:41:19.501Z"}
debug: Executing (b44a4836-f227-4f65-b02f-973c15a8067f): START TRANSACTION; {"timestamp":"2023-08-15T06:41:19.502Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:19.504Z"}
debug: Executing (b44a4836-f227-4f65-b02f-973c15a8067f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:41:19.510Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:19.514Z"}
debug: Executing (b44a4836-f227-4f65-b02f-973c15a8067f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_2b715de1e8ba4f849a9dc6dd344ca489$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:41:19.515 +00:00','2023-08-15 06:41:19.515 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_2b715de1e8ba4f849a9dc6dd344ca489$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:41:19.521Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:19.523Z"}
debug: Executing (b44a4836-f227-4f65-b02f-973c15a8067f): COMMIT; {"timestamp":"2023-08-15T06:41:19.528Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:19.529Z"}
info: User Already exists {"timestamp":"2023-08-15T06:41:19.530Z"}
info: User Created {"timestamp":"2023-08-15T06:41:19.531Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:19.535Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:19.556Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:19.564Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:19.572Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:19.580Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:19.581Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:19.582Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:19.583Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:19.584Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:19.588Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:19.599Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:19.605Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:19.607Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:19.613Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:19.616Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:19.617Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:19.628Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:19.630Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:19.632Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:19.643Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:41:37.461Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:41:37.559Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:41:37.560Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:41:37.560Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:41:37.561Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:41:37.594Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:41:37.595Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:41:37.645Z"}
debug: Executing (56b86398-b7bb-4d90-a13f-a9705b44c976): START TRANSACTION; {"timestamp":"2023-08-15T06:41:37.646Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:37.647Z"}
debug: Executing (56b86398-b7bb-4d90-a13f-a9705b44c976): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:41:37.653Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:37.656Z"}
debug: Executing (56b86398-b7bb-4d90-a13f-a9705b44c976): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_3cb5cd5a5ebb4c14bc39379c2f059d10$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:41:37.658 +00:00','2023-08-15 06:41:37.658 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_3cb5cd5a5ebb4c14bc39379c2f059d10$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:41:37.663Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:37.664Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:37.668Z"}
debug: Executing (56b86398-b7bb-4d90-a13f-a9705b44c976): COMMIT; {"timestamp":"2023-08-15T06:41:37.670Z"}
info: User Already exists {"timestamp":"2023-08-15T06:41:37.673Z"}
info: User Created {"timestamp":"2023-08-15T06:41:37.674Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:37.677Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:37.695Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:37.704Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:37.714Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:37.722Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:37.724Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:37.726Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:37.727Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:37.729Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:37.732Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:37.743Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:37.748Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:37.749Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:37.758Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:37.762Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:37.763Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:37.777Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:37.780Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:37.783Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:37.796Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:41:45.656Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:41:45.758Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:41:45.758Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:41:45.759Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:41:45.759Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:41:45.774Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:41:45.775Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:41:45.820Z"}
debug: Executing (f416b977-1881-4d9e-94b3-6a8623c966a4): START TRANSACTION; {"timestamp":"2023-08-15T06:41:45.821Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:45.822Z"}
debug: Executing (f416b977-1881-4d9e-94b3-6a8623c966a4): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:41:45.827Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:45.831Z"}
debug: Executing (f416b977-1881-4d9e-94b3-6a8623c966a4): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_49e74ad09d654288b7d93dc166f1ad9a$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:41:45.833 +00:00','2023-08-15 06:41:45.833 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_49e74ad09d654288b7d93dc166f1ad9a$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:41:45.838Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:45.840Z"}
debug: Executing (f416b977-1881-4d9e-94b3-6a8623c966a4): COMMIT; {"timestamp":"2023-08-15T06:41:45.844Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:45.845Z"}
info: User Already exists {"timestamp":"2023-08-15T06:41:45.846Z"}
info: User Created {"timestamp":"2023-08-15T06:41:45.847Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:45.850Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:45.866Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:45.874Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:41:45.879Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:45.887Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:45.889Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:45.890Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:45.891Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:41:45.892Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:45.895Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:45.905Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:41:45.911Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:45.912Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:45.918Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:41:45.922Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:45.924Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:45.936Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:41:45.939Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:41:45.940Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:41:45.953Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:42:09.226Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:42:09.324Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:42:09.325Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:42:09.325Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:42:09.326Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:42:09.341Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:42:09.342Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:42:09.386Z"}
debug: Executing (a44285fa-a7ab-463b-9ee7-0b6fa400e382): START TRANSACTION; {"timestamp":"2023-08-15T06:42:09.388Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:09.389Z"}
debug: Executing (a44285fa-a7ab-463b-9ee7-0b6fa400e382): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:42:09.396Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:09.401Z"}
debug: Executing (a44285fa-a7ab-463b-9ee7-0b6fa400e382): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_15248a8ac5b145af946d91c468c0fff3$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:42:09.403 +00:00','2023-08-15 06:42:09.403 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_15248a8ac5b145af946d91c468c0fff3$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:42:09.407Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:09.408Z"}
debug: Executing (a44285fa-a7ab-463b-9ee7-0b6fa400e382): COMMIT; {"timestamp":"2023-08-15T06:42:09.412Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:09.413Z"}
info: User Already exists {"timestamp":"2023-08-15T06:42:09.414Z"}
info: User Created {"timestamp":"2023-08-15T06:42:09.414Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:09.418Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:09.434Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:09.442Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:09.448Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:09.455Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:09.457Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:09.458Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:09.459Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:09.461Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:09.464Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:09.476Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:09.482Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:09.484Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:09.490Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:09.493Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:09.495Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:09.505Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:09.508Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:09.509Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:09.520Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:42:22.531Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:42:22.634Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:42:22.635Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:42:22.635Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:42:22.636Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:42:22.651Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:42:22.651Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:42:22.697Z"}
debug: Executing (18de3d95-e6f4-4b60-9ba0-e56ba0c76874): START TRANSACTION; {"timestamp":"2023-08-15T06:42:22.699Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:22.700Z"}
debug: Executing (18de3d95-e6f4-4b60-9ba0-e56ba0c76874): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:42:22.707Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:22.710Z"}
debug: Executing (18de3d95-e6f4-4b60-9ba0-e56ba0c76874): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_75b6d9d69f884b748f3cc10dceca6c46$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:42:22.712 +00:00','2023-08-15 06:42:22.712 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_75b6d9d69f884b748f3cc10dceca6c46$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:42:22.717Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:22.719Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:22.722Z"}
debug: Executing (18de3d95-e6f4-4b60-9ba0-e56ba0c76874): COMMIT; {"timestamp":"2023-08-15T06:42:22.724Z"}
info: User Already exists {"timestamp":"2023-08-15T06:42:22.725Z"}
info: User Created {"timestamp":"2023-08-15T06:42:22.726Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:22.729Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:22.745Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:22.753Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:22.759Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:22.767Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:22.768Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:22.770Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:22.771Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:22.773Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:22.775Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:22.785Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:22.791Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:22.792Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:22.798Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:22.803Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:22.804Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:22.814Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:22.817Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:22.818Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:22.832Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:42:26.946Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:42:27.049Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:42:27.050Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:42:27.051Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:42:27.051Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:42:27.066Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:42:27.067Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:42:27.112Z"}
debug: Executing (ef3a9d2c-d0aa-4021-89e2-3eff6d5189c3): START TRANSACTION; {"timestamp":"2023-08-15T06:42:27.114Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:27.114Z"}
debug: Executing (ef3a9d2c-d0aa-4021-89e2-3eff6d5189c3): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:42:27.121Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:27.124Z"}
debug: Executing (ef3a9d2c-d0aa-4021-89e2-3eff6d5189c3): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_d3910468cb7a47c98c69f8464f3306c8$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:42:27.126 +00:00','2023-08-15 06:42:27.126 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_d3910468cb7a47c98c69f8464f3306c8$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:42:27.130Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:27.131Z"}
debug: Executing (ef3a9d2c-d0aa-4021-89e2-3eff6d5189c3): COMMIT; {"timestamp":"2023-08-15T06:42:27.136Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:27.136Z"}
info: User Already exists {"timestamp":"2023-08-15T06:42:27.138Z"}
info: User Created {"timestamp":"2023-08-15T06:42:27.138Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:27.141Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:27.158Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:27.165Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:27.172Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:27.179Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:27.180Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:27.182Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:27.185Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:27.190Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:27.200Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:27.214Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:27.220Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:27.222Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:27.229Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:27.233Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:27.236Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:27.247Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:27.252Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:27.254Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:27.266Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:42:42.118Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:42:42.222Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:42:42.223Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:42:42.224Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:42:42.225Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:42:42.240Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:42:42.241Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:42:42.288Z"}
debug: Executing (ee9f1604-4ebe-4678-aa8b-12ff8469fe35): START TRANSACTION; {"timestamp":"2023-08-15T06:42:42.289Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:42.290Z"}
debug: Executing (ee9f1604-4ebe-4678-aa8b-12ff8469fe35): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:42:42.295Z"}
debug: Executing (ee9f1604-4ebe-4678-aa8b-12ff8469fe35): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_d4c6a05e914543bcb48473cd579e7585$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:42:42.302 +00:00','2023-08-15 06:42:42.302 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_d4c6a05e914543bcb48473cd579e7585$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:42:42.306Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:42.307Z"}
debug: Executing (ee9f1604-4ebe-4678-aa8b-12ff8469fe35): COMMIT; {"timestamp":"2023-08-15T06:42:42.312Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:42.316Z"}
info: User Already exists {"timestamp":"2023-08-15T06:42:42.317Z"}
info: User Created {"timestamp":"2023-08-15T06:42:42.317Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:42.329Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:42.335Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:42.352Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:42.359Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:42:42.365Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:42.372Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:42.373Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:42.374Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:42.375Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:42:42.376Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:42.379Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:42.389Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:42:42.394Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:42.395Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:42.402Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:42:42.405Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:42.406Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:42.416Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:42:42.419Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:42:42.420Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:42:42.432Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:47:32.441Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:47:32.563Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:47:32.564Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:47:32.564Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:47:32.565Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:47:32.581Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:47:32.581Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:47:32.626Z"}
debug: Executing (ade087a8-72d6-45c4-9c3c-7a0ce8c8e3af): START TRANSACTION; {"timestamp":"2023-08-15T06:47:32.626Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:47:32.627Z"}
debug: Executing (ade087a8-72d6-45c4-9c3c-7a0ce8c8e3af): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:47:32.632Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:47:32.637Z"}
debug: Executing (ade087a8-72d6-45c4-9c3c-7a0ce8c8e3af): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e4394c9f01d640749ecd20309b9f8b42$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:47:32.639 +00:00','2023-08-15 06:47:32.639 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e4394c9f01d640749ecd20309b9f8b42$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:47:32.643Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:47:32.644Z"}
debug: Executing (ade087a8-72d6-45c4-9c3c-7a0ce8c8e3af): COMMIT; {"timestamp":"2023-08-15T06:47:32.649Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:47:32.651Z"}
info: User Already exists {"timestamp":"2023-08-15T06:47:32.654Z"}
info: User Created {"timestamp":"2023-08-15T06:47:32.654Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:47:32.657Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:47:32.675Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:47:32.682Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:47:32.689Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:47:32.696Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:47:32.697Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:47:32.698Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:47:32.699Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:47:32.702Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:47:32.705Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:47:32.715Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:47:32.723Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:47:32.725Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:47:32.730Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:47:32.735Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:47:32.737Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:47:32.746Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:47:32.749Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:47:32.751Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:47:32.761Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:48:44.459Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:48:44.554Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:48:44.555Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:48:44.556Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:48:44.557Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:48:44.573Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:48:44.573Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:48:44.616Z"}
debug: Executing (d496b6d3-b80c-4b54-bca2-f7d48cf44c80): START TRANSACTION; {"timestamp":"2023-08-15T06:48:44.617Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:48:44.618Z"}
debug: Executing (d496b6d3-b80c-4b54-bca2-f7d48cf44c80): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:48:44.624Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:48:44.627Z"}
debug: Executing (d496b6d3-b80c-4b54-bca2-f7d48cf44c80): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_3bcfa4064e40455ba7ee2f961d053ae4$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:48:44.630 +00:00','2023-08-15 06:48:44.630 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_3bcfa4064e40455ba7ee2f961d053ae4$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:48:44.634Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:48:44.635Z"}
debug: Executing (d496b6d3-b80c-4b54-bca2-f7d48cf44c80): COMMIT; {"timestamp":"2023-08-15T06:48:44.639Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:48:44.640Z"}
info: User Already exists {"timestamp":"2023-08-15T06:48:44.641Z"}
info: User Created {"timestamp":"2023-08-15T06:48:44.641Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:48:44.645Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:48:44.661Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:48:44.668Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:48:44.675Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:48:44.684Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:48:44.686Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:48:44.688Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:48:44.690Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:48:44.693Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:48:44.696Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:48:44.709Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:48:44.715Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:48:44.717Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:48:44.724Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:48:44.727Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:48:44.729Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:48:44.740Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:48:44.743Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:48:44.744Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:48:44.756Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:50:05.213Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:50:05.311Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:50:05.312Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:50:05.312Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:50:05.313Z"}
error: error connectibg redis  The client is closed {"stack":"Error: The client is closed\n    at Commander._RedisClient_sendCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:490:31)\n    at Commander.commandsExecutor (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:188:154)\n    at BaseClass.<computed> [as auth] (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\commander.js:8:29)\n    at connectToRedisStore (D:\\esa\\backend\\index.js:50:45)\n    at Server.<anonymous> (D:\\esa\\backend\\index.js:102:5)\n    at Object.onceWrapper (node:events:627:28)\n    at Server.emit (node:events:513:28)\n    at emitListeningNT (node:net:1774:10)\n    at process.processTicksAndRejections (node:internal/process/task_queues:81:21)","timestamp":"2023-08-15T06:50:05.321Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:50:05.373Z"}
debug: Executing (ebaaa12a-c5d6-4826-b98e-4aa158e6918f): START TRANSACTION; {"timestamp":"2023-08-15T06:50:05.376Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:05.377Z"}
debug: Executing (ebaaa12a-c5d6-4826-b98e-4aa158e6918f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:50:05.383Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:05.386Z"}
debug: Executing (ebaaa12a-c5d6-4826-b98e-4aa158e6918f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_652b6428ade1490cbebfc94262f0dd7d$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:50:05.388 +00:00','2023-08-15 06:50:05.388 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_652b6428ade1490cbebfc94262f0dd7d$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:50:05.393Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:05.394Z"}
debug: Executing (ebaaa12a-c5d6-4826-b98e-4aa158e6918f): COMMIT; {"timestamp":"2023-08-15T06:50:05.398Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:05.399Z"}
info: User Already exists {"timestamp":"2023-08-15T06:50:05.401Z"}
info: User Created {"timestamp":"2023-08-15T06:50:05.401Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:05.405Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:05.421Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:05.429Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:05.438Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:05.446Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:05.447Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:05.448Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:05.449Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:05.451Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:05.453Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:05.463Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:05.468Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:05.469Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:05.475Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:05.478Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:05.480Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:05.490Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:05.493Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:05.494Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:05.504Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:50:15.777Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:50:15.877Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:50:15.878Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:50:15.879Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:50:15.879Z"}
error: error connectibg redis  The client is closed {"stack":"Error: The client is closed\n    at Commander._RedisClient_sendCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:490:31)\n    at Commander.commandsExecutor (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:188:154)\n    at BaseClass.<computed> [as auth] (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\commander.js:8:29)\n    at connectToRedisStore (D:\\esa\\backend\\index.js:50:44)\n    at Server.<anonymous> (D:\\esa\\backend\\index.js:102:5)\n    at Object.onceWrapper (node:events:627:28)\n    at Server.emit (node:events:513:28)\n    at emitListeningNT (node:net:1774:10)\n    at process.processTicksAndRejections (node:internal/process/task_queues:81:21)","timestamp":"2023-08-15T06:50:15.887Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:50:15.942Z"}
debug: Executing (d5be4de5-e547-4e89-9030-ae4e8f73df6c): START TRANSACTION; {"timestamp":"2023-08-15T06:50:15.944Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:15.945Z"}
debug: Executing (d5be4de5-e547-4e89-9030-ae4e8f73df6c): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:50:15.952Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:15.955Z"}
debug: Executing (d5be4de5-e547-4e89-9030-ae4e8f73df6c): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_2351fb86c04649e9bfb6625762b0f9fd$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:50:15.957 +00:00','2023-08-15 06:50:15.957 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_2351fb86c04649e9bfb6625762b0f9fd$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:50:15.962Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:15.964Z"}
debug: Executing (d5be4de5-e547-4e89-9030-ae4e8f73df6c): COMMIT; {"timestamp":"2023-08-15T06:50:15.968Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:15.969Z"}
info: User Already exists {"timestamp":"2023-08-15T06:50:15.970Z"}
info: User Created {"timestamp":"2023-08-15T06:50:15.970Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:15.973Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:15.990Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:15.997Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:16.004Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:16.012Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:16.013Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:16.014Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:16.015Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:16.017Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:16.019Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:16.030Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:16.036Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:16.037Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:16.044Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:16.047Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:16.049Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:16.059Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:16.062Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:16.064Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:16.074Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:50:46.221Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:50:46.330Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:50:46.330Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:50:46.331Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:50:46.331Z"}
error: error connectibg redis  The client is closed {"stack":"Error: The client is closed\n    at Commander._RedisClient_sendCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:490:31)\n    at Commander.commandsExecutor (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:188:154)\n    at BaseClass.<computed> [as auth] (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\commander.js:8:29)\n    at connectToRedisStore (D:\\esa\\backend\\index.js:50:44)\n    at Server.<anonymous> (D:\\esa\\backend\\index.js:102:5)\n    at Object.onceWrapper (node:events:627:28)\n    at Server.emit (node:events:513:28)\n    at emitListeningNT (node:net:1774:10)\n    at process.processTicksAndRejections (node:internal/process/task_queues:81:21)","timestamp":"2023-08-15T06:50:46.339Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:50:46.399Z"}
debug: Executing (b62ae334-4c5e-4bb1-92d5-470f32f835a7): START TRANSACTION; {"timestamp":"2023-08-15T06:50:46.400Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:46.401Z"}
debug: Executing (b62ae334-4c5e-4bb1-92d5-470f32f835a7): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:50:46.407Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:46.411Z"}
debug: Executing (b62ae334-4c5e-4bb1-92d5-470f32f835a7): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_369532b5d0484749a6bbeb688f89e232$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:50:46.413 +00:00','2023-08-15 06:50:46.413 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_369532b5d0484749a6bbeb688f89e232$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:50:46.417Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:46.418Z"}
debug: Executing (b62ae334-4c5e-4bb1-92d5-470f32f835a7): COMMIT; {"timestamp":"2023-08-15T06:50:46.423Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:46.424Z"}
info: User Already exists {"timestamp":"2023-08-15T06:50:46.425Z"}
info: User Created {"timestamp":"2023-08-15T06:50:46.425Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:46.429Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:46.445Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:46.453Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:50:46.460Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:46.468Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:46.469Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:46.470Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:46.471Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:50:46.472Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:46.476Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:46.487Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:50:46.493Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:46.495Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:46.501Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:50:46.504Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:46.506Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:46.516Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:50:46.519Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:50:46.520Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:50:46.532Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:51:15.695Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:51:15.793Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:51:15.793Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:51:15.794Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:51:15.794Z"}
error: error connectibg redis  The client is closed {"stack":"Error: The client is closed\n    at Commander._RedisClient_sendCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:490:31)\n    at Commander.commandsExecutor (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:188:154)\n    at BaseClass.<computed> [as auth] (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\commander.js:8:29)\n    at connectToRedisStore (D:\\esa\\backend\\index.js:50:44)\n    at Server.<anonymous> (D:\\esa\\backend\\index.js:102:5)\n    at Object.onceWrapper (node:events:627:28)\n    at Server.emit (node:events:513:28)\n    at emitListeningNT (node:net:1774:10)\n    at process.processTicksAndRejections (node:internal/process/task_queues:81:21)","timestamp":"2023-08-15T06:51:15.802Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:51:15.855Z"}
debug: Executing (0daa58fe-fc44-4ea4-bb9c-bde9a4f7c477): START TRANSACTION; {"timestamp":"2023-08-15T06:51:15.856Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:51:15.858Z"}
debug: Executing (0daa58fe-fc44-4ea4-bb9c-bde9a4f7c477): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:51:15.866Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:51:15.870Z"}
debug: Executing (0daa58fe-fc44-4ea4-bb9c-bde9a4f7c477): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_479cbd7955714c3fbdeef55e3d87b861$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:51:15.873 +00:00','2023-08-15 06:51:15.873 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_479cbd7955714c3fbdeef55e3d87b861$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:51:15.878Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:51:15.879Z"}
debug: Executing (0daa58fe-fc44-4ea4-bb9c-bde9a4f7c477): COMMIT; {"timestamp":"2023-08-15T06:51:15.884Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:51:15.885Z"}
info: User Already exists {"timestamp":"2023-08-15T06:51:15.886Z"}
info: User Created {"timestamp":"2023-08-15T06:51:15.886Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:51:15.890Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:51:15.907Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:51:15.915Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:51:15.921Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:51:15.929Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:51:15.930Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:51:15.931Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:51:15.932Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:51:15.934Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:51:15.936Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:51:15.947Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:51:15.953Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:51:15.954Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:51:15.962Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:51:15.965Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:51:15.966Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:51:15.977Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:51:15.980Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:51:15.981Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:51:15.993Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:51:35.397Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:51:35.491Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:51:35.491Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:51:35.492Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:51:35.493Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:51:35.506Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:51:35.506Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:51:35.549Z"}
debug: Executing (6fda3b15-4b44-4fef-acf3-a1945c2b2793): START TRANSACTION; {"timestamp":"2023-08-15T06:51:35.550Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:51:35.551Z"}
debug: Executing (6fda3b15-4b44-4fef-acf3-a1945c2b2793): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:51:35.557Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:51:35.561Z"}
debug: Executing (6fda3b15-4b44-4fef-acf3-a1945c2b2793): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_8c30e68fec3b4d21bec08078471b423b$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:51:35.563 +00:00','2023-08-15 06:51:35.563 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_8c30e68fec3b4d21bec08078471b423b$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:51:35.568Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:51:35.569Z"}
debug: Executing (6fda3b15-4b44-4fef-acf3-a1945c2b2793): COMMIT; {"timestamp":"2023-08-15T06:51:35.574Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:51:35.574Z"}
info: User Already exists {"timestamp":"2023-08-15T06:51:35.576Z"}
info: User Created {"timestamp":"2023-08-15T06:51:35.576Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:51:35.579Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:51:35.595Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:51:35.602Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:51:35.608Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:51:35.615Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:51:35.617Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:51:35.618Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:51:35.619Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:51:35.621Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:51:35.624Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:51:35.633Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:51:35.639Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:51:35.641Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:51:35.647Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:51:35.650Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:51:35.652Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:51:35.662Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:51:35.665Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:51:35.666Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:51:35.677Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:52:08.692Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:52:12.693Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:52:12.788Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:52:12.789Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:52:12.790Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:52:12.790Z"}
error: error connectibg redis  Invalid argument type {"stack":"TypeError: Invalid argument type\n    at encodeCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\RESP2\\encoder.js:17:19)\n    at RedisCommandsQueue.getCommandToSend (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\commands-queue.js:138:45)\n    at Commander._RedisClient_tick (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:515:76)\n    at Commander._RedisClient_sendCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:502:82)\n    at Commander.commandsExecutor (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:188:154)\n    at BaseClass.<computed> [as auth] (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\commander.js:8:29)\n    at connectToRedisStore (D:\\esa\\backend\\index.js:54:44)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2023-08-15T06:52:12.811Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:52:12.866Z"}
debug: Executing (57924c65-7630-42ca-9f66-461d8bf26140): START TRANSACTION; {"timestamp":"2023-08-15T06:52:12.867Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:12.869Z"}
debug: Executing (57924c65-7630-42ca-9f66-461d8bf26140): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:52:12.874Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:12.878Z"}
debug: Executing (57924c65-7630-42ca-9f66-461d8bf26140): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e609536a333f4fffa74ae057d26657f4$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:52:12.879 +00:00','2023-08-15 06:52:12.879 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e609536a333f4fffa74ae057d26657f4$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:52:12.883Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:12.884Z"}
debug: Executing (57924c65-7630-42ca-9f66-461d8bf26140): COMMIT; {"timestamp":"2023-08-15T06:52:12.889Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:12.889Z"}
info: User Already exists {"timestamp":"2023-08-15T06:52:12.890Z"}
info: User Created {"timestamp":"2023-08-15T06:52:12.891Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:12.894Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:12.910Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:12.916Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:12.923Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:12.930Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:12.931Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:12.932Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:12.932Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:12.934Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:12.936Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:12.946Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:12.951Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:12.953Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:12.959Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:12.962Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:12.963Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:12.973Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:12.976Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:12.977Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:12.988Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:52:20.940Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:52:21.042Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:52:21.043Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:52:21.043Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:52:21.044Z"}
error: error connectibg redis  Invalid argument type {"stack":"TypeError: Invalid argument type\n    at encodeCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\RESP2\\encoder.js:17:19)\n    at RedisCommandsQueue.getCommandToSend (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\commands-queue.js:138:45)\n    at Commander._RedisClient_tick (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:515:76)\n    at Commander._RedisClient_sendCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:502:82)\n    at Commander.commandsExecutor (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:188:154)\n    at BaseClass.<computed> [as auth] (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\commander.js:8:29)\n    at connectToRedisStore (D:\\esa\\backend\\index.js:54:44)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2023-08-15T06:52:21.059Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:52:21.103Z"}
debug: Executing (88d6c489-feb3-456c-a105-0f8ab87a8b70): START TRANSACTION; {"timestamp":"2023-08-15T06:52:21.105Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:21.106Z"}
debug: Executing (88d6c489-feb3-456c-a105-0f8ab87a8b70): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:52:21.112Z"}
debug: Executing (88d6c489-feb3-456c-a105-0f8ab87a8b70): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_faf1ce482f41424cb352bea399df6218$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:52:21.117 +00:00','2023-08-15 06:52:21.117 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_faf1ce482f41424cb352bea399df6218$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:52:21.122Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:21.125Z"}
debug: Executing (88d6c489-feb3-456c-a105-0f8ab87a8b70): COMMIT; {"timestamp":"2023-08-15T06:52:21.128Z"}
info: User Already exists {"timestamp":"2023-08-15T06:52:21.130Z"}
info: User Created {"timestamp":"2023-08-15T06:52:21.131Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:21.133Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:21.138Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:21.144Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:21.161Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:21.168Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:21.175Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:21.181Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:21.182Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:21.184Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:21.185Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:21.187Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:21.190Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:21.202Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:21.209Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:21.210Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:21.216Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:21.219Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:21.221Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:21.231Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:21.234Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:21.235Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:21.247Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:52:55.080Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:52:55.188Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:52:55.188Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:52:55.189Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:52:55.190Z"}
error: error connectibg redis  Invalid argument type {"stack":"TypeError: Invalid argument type\n    at encodeCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\RESP2\\encoder.js:17:19)\n    at RedisCommandsQueue.getCommandToSend (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\commands-queue.js:138:45)\n    at Commander._RedisClient_tick (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:515:76)\n    at Commander._RedisClient_sendCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:502:82)\n    at Commander.commandsExecutor (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:188:154)\n    at BaseClass.<computed> [as auth] (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\commander.js:8:29)\n    at connectToRedisStore (D:\\esa\\backend\\index.js:54:44)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2023-08-15T06:52:55.206Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:52:55.251Z"}
debug: Executing (91d0276a-c628-4aca-9c6b-a347def4ba6f): START TRANSACTION; {"timestamp":"2023-08-15T06:52:55.253Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:55.255Z"}
debug: Executing (91d0276a-c628-4aca-9c6b-a347def4ba6f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:52:55.261Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:55.265Z"}
debug: Executing (91d0276a-c628-4aca-9c6b-a347def4ba6f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_9b9a1476b327452c98362d7cc5739ce7$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:52:55.267 +00:00','2023-08-15 06:52:55.267 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_9b9a1476b327452c98362d7cc5739ce7$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:52:55.273Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:55.274Z"}
debug: Executing (91d0276a-c628-4aca-9c6b-a347def4ba6f): COMMIT; {"timestamp":"2023-08-15T06:52:55.278Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:55.279Z"}
info: User Already exists {"timestamp":"2023-08-15T06:52:55.280Z"}
info: User Created {"timestamp":"2023-08-15T06:52:55.281Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:55.284Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:55.299Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:55.307Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:55.313Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:55.321Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:55.322Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:55.323Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:55.324Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:55.325Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:55.328Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:55.338Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:55.344Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:55.345Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:55.350Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:55.354Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:55.356Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:55.366Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:55.369Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:55.371Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:55.382Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:52:57.460Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:52:57.561Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:52:57.562Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:52:57.562Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:52:57.563Z"}
error: error connectibg redis  Invalid argument type {"stack":"TypeError: Invalid argument type\n    at encodeCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\RESP2\\encoder.js:17:19)\n    at RedisCommandsQueue.getCommandToSend (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\commands-queue.js:138:45)\n    at Commander._RedisClient_tick (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:515:76)\n    at Commander._RedisClient_sendCommand (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:502:82)\n    at Commander.commandsExecutor (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\client\\index.js:188:154)\n    at BaseClass.<computed> [as auth] (D:\\esa\\backend\\node_modules\\@redis\\client\\dist\\lib\\commander.js:8:29)\n    at connectToRedisStore (D:\\esa\\backend\\index.js:54:44)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)","timestamp":"2023-08-15T06:52:57.579Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:52:57.628Z"}
debug: Executing (720fcbac-0c3a-463f-9742-260f610b00d9): START TRANSACTION; {"timestamp":"2023-08-15T06:52:57.629Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:57.630Z"}
debug: Executing (720fcbac-0c3a-463f-9742-260f610b00d9): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:52:57.636Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:57.638Z"}
debug: Executing (720fcbac-0c3a-463f-9742-260f610b00d9): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_54bfa8687a4c4b1196531672ae421722$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:52:57.641 +00:00','2023-08-15 06:52:57.641 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_54bfa8687a4c4b1196531672ae421722$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:52:57.645Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:57.646Z"}
debug: Executing (720fcbac-0c3a-463f-9742-260f610b00d9): COMMIT; {"timestamp":"2023-08-15T06:52:57.650Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:57.651Z"}
info: User Already exists {"timestamp":"2023-08-15T06:52:57.652Z"}
info: User Created {"timestamp":"2023-08-15T06:52:57.653Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:57.657Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:57.673Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:57.680Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:52:57.687Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:57.694Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:57.695Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:57.696Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:57.697Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:52:57.698Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:57.701Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:57.711Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:52:57.717Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:57.719Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:57.725Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:52:57.728Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:57.729Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:57.739Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:52:57.742Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:52:57.743Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:52:57.755Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:54:06.701Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:54:06.798Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:54:06.799Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:54:06.800Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:54:06.800Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:54:06.814Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:54:06.814Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:54:06.856Z"}
debug: Executing (58c5d26e-3248-4965-9d93-4d3eefe74bb9): START TRANSACTION; {"timestamp":"2023-08-15T06:54:06.857Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:54:06.858Z"}
debug: Executing (58c5d26e-3248-4965-9d93-4d3eefe74bb9): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:54:06.865Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:54:06.867Z"}
debug: Executing (58c5d26e-3248-4965-9d93-4d3eefe74bb9): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_9c795dd57e2b45e5a2d13028badd394e$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:54:06.870 +00:00','2023-08-15 06:54:06.870 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_9c795dd57e2b45e5a2d13028badd394e$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:54:06.874Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:54:06.875Z"}
debug: Executing (58c5d26e-3248-4965-9d93-4d3eefe74bb9): COMMIT; {"timestamp":"2023-08-15T06:54:06.880Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:54:06.880Z"}
info: User Already exists {"timestamp":"2023-08-15T06:54:06.881Z"}
info: User Created {"timestamp":"2023-08-15T06:54:06.882Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:54:06.886Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:54:06.901Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:54:06.907Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:54:06.914Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:54:06.921Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:54:06.922Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:54:06.924Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:54:06.925Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:54:06.926Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:54:06.929Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:54:06.938Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:54:06.944Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:54:06.945Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:54:06.951Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:54:06.954Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:54:06.956Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:54:06.965Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:54:06.968Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:54:06.969Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:54:06.979Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:54:09.940Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:54:10.039Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:54:10.040Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:54:10.040Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:54:10.041Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:54:10.059Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:54:10.060Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:54:10.103Z"}
debug: Executing (bdf0d969-de17-4098-b3fd-c7fe9c316d21): START TRANSACTION; {"timestamp":"2023-08-15T06:54:10.104Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:54:10.106Z"}
debug: Executing (bdf0d969-de17-4098-b3fd-c7fe9c316d21): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:54:10.112Z"}
debug: Executing (bdf0d969-de17-4098-b3fd-c7fe9c316d21): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_de14332d17f54954bc63ba7ff5224fba$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:54:10.118 +00:00','2023-08-15 06:54:10.118 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_de14332d17f54954bc63ba7ff5224fba$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:54:10.124Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:54:10.125Z"}
debug: Executing (bdf0d969-de17-4098-b3fd-c7fe9c316d21): COMMIT; {"timestamp":"2023-08-15T06:54:10.130Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:54:10.132Z"}
info: User Already exists {"timestamp":"2023-08-15T06:54:10.133Z"}
info: User Created {"timestamp":"2023-08-15T06:54:10.133Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:54:10.137Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:54:10.142Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:54:10.163Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:54:10.172Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:54:10.180Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:54:10.189Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:54:10.191Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:54:10.192Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:54:10.194Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:54:10.197Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:54:10.203Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:54:10.218Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:54:10.224Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:54:10.226Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:54:10.232Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:54:10.237Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:54:10.238Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:54:10.247Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:54:10.251Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:54:10.253Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:54:10.265Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:55:54.557Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:55:54.657Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:55:54.657Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:55:54.658Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:55:54.659Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:55:54.676Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:55:54.677Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:55:54.716Z"}
debug: Executing (91c1cabf-b62c-49e2-8bc7-9867f5e2845e): START TRANSACTION; {"timestamp":"2023-08-15T06:55:54.718Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:55:54.719Z"}
debug: Executing (91c1cabf-b62c-49e2-8bc7-9867f5e2845e): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:55:54.724Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:55:54.729Z"}
debug: Executing (91c1cabf-b62c-49e2-8bc7-9867f5e2845e): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_9b093a4892ff4fe9b9371e2188159abb$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:55:54.731 +00:00','2023-08-15 06:55:54.731 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_9b093a4892ff4fe9b9371e2188159abb$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:55:54.736Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:55:54.737Z"}
debug: Executing (91c1cabf-b62c-49e2-8bc7-9867f5e2845e): COMMIT; {"timestamp":"2023-08-15T06:55:54.741Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:55:54.742Z"}
info: User Already exists {"timestamp":"2023-08-15T06:55:54.744Z"}
info: User Created {"timestamp":"2023-08-15T06:55:54.744Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:55:54.749Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:55:54.765Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:55:54.771Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:55:54.779Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:55:54.786Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:55:54.787Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:55:54.788Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:55:54.789Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:55:54.791Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:55:54.794Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:55:54.803Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:55:54.809Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:55:54.811Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:55:54.817Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:55:54.821Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:55:54.823Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:55:54.834Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:55:54.836Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:55:54.838Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:55:54.848Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:56:26.445Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:56:26.545Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:56:26.545Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:56:26.546Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:56:26.546Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:56:26.564Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:56:26.565Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:56:26.606Z"}
debug: Executing (a12dad9b-2031-487c-9eec-604459916de6): START TRANSACTION; {"timestamp":"2023-08-15T06:56:26.608Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:56:26.610Z"}
debug: Executing (a12dad9b-2031-487c-9eec-604459916de6): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:56:26.616Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:56:26.620Z"}
debug: Executing (a12dad9b-2031-487c-9eec-604459916de6): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_d6f5aa0f766240a2a4da60f0fb1f789d$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:56:26.622 +00:00','2023-08-15 06:56:26.622 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_d6f5aa0f766240a2a4da60f0fb1f789d$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:56:26.627Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:56:26.628Z"}
debug: Executing (a12dad9b-2031-487c-9eec-604459916de6): COMMIT; {"timestamp":"2023-08-15T06:56:26.633Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:56:26.634Z"}
info: User Already exists {"timestamp":"2023-08-15T06:56:26.635Z"}
info: User Created {"timestamp":"2023-08-15T06:56:26.635Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:56:26.639Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:56:26.655Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:56:26.662Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:56:26.668Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:56:26.677Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:56:26.679Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:56:26.680Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:56:26.681Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:56:26.683Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:56:26.685Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:56:26.695Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:56:26.701Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:56:26.702Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:56:26.708Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:56:26.712Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:56:26.714Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:56:26.723Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:56:26.727Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:56:26.728Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:56:26.739Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:56:28.274Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:56:28.375Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:56:28.376Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:56:28.377Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:56:28.377Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:56:28.398Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:56:28.399Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:56:28.444Z"}
debug: Executing (956db736-c94a-407e-bd94-d088cd48aa5f): START TRANSACTION; {"timestamp":"2023-08-15T06:56:28.446Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:56:28.447Z"}
debug: Executing (956db736-c94a-407e-bd94-d088cd48aa5f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:56:28.452Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:56:28.456Z"}
debug: Executing (956db736-c94a-407e-bd94-d088cd48aa5f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_0ad1de86549042e481b0be2c6c0baccc$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:56:28.458 +00:00','2023-08-15 06:56:28.458 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_0ad1de86549042e481b0be2c6c0baccc$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:56:28.465Z"}
debug: Executing (956db736-c94a-407e-bd94-d088cd48aa5f): COMMIT; {"timestamp":"2023-08-15T06:56:28.496Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:56:28.497Z"}
info: User Already exists {"timestamp":"2023-08-15T06:56:28.499Z"}
info: User Created {"timestamp":"2023-08-15T06:56:28.500Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:56:28.503Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:56:28.513Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:56:28.533Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:56:28.540Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:56:28.548Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:56:28.556Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:56:28.558Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:56:28.561Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:56:28.563Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:56:28.565Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:56:28.568Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:56:28.579Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:56:28.586Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:56:28.587Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:56:28.594Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:56:28.598Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:56:28.600Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:56:28.612Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:56:28.615Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:56:28.616Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:56:28.628Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:58:22.782Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:58:22.883Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:58:22.884Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:58:22.884Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:58:22.885Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:58:22.908Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:58:22.909Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:58:22.960Z"}
debug: Executing (05d21c17-be52-4d1a-9342-25596ccab382): START TRANSACTION; {"timestamp":"2023-08-15T06:58:22.961Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:58:22.962Z"}
debug: Executing (05d21c17-be52-4d1a-9342-25596ccab382): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:58:22.970Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:58:22.974Z"}
debug: Executing (05d21c17-be52-4d1a-9342-25596ccab382): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_2c4c1cbcc0ca4baabda42bc9debeed29$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:58:22.976 +00:00','2023-08-15 06:58:22.976 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_2c4c1cbcc0ca4baabda42bc9debeed29$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:58:22.979Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:58:22.980Z"}
debug: Executing (05d21c17-be52-4d1a-9342-25596ccab382): COMMIT; {"timestamp":"2023-08-15T06:58:22.985Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:58:22.985Z"}
info: User Already exists {"timestamp":"2023-08-15T06:58:22.987Z"}
info: User Created {"timestamp":"2023-08-15T06:58:22.988Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:58:22.991Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:58:23.009Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:58:23.017Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:58:23.024Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:58:23.034Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:58:23.037Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:58:23.039Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:58:23.041Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:58:23.043Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:58:23.046Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:58:23.058Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:58:23.066Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:58:23.068Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:58:23.075Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:58:23.078Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:58:23.080Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:58:23.090Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:58:23.093Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:58:23.095Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:58:23.115Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:59:07.589Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:59:07.679Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:59:07.680Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:59:07.681Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:59:07.682Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:59:07.699Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:59:07.699Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:59:07.739Z"}
debug: Executing (291759a6-d4d9-42da-9cf8-4272fe67393a): START TRANSACTION; {"timestamp":"2023-08-15T06:59:07.740Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:07.741Z"}
debug: Executing (291759a6-d4d9-42da-9cf8-4272fe67393a): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:59:07.746Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:07.749Z"}
debug: Executing (291759a6-d4d9-42da-9cf8-4272fe67393a): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_d40dc406f0ac4ee8997aa6c892f96378$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:59:07.751 +00:00','2023-08-15 06:59:07.751 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_d40dc406f0ac4ee8997aa6c892f96378$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:59:07.756Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:07.757Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:07.761Z"}
debug: Executing (291759a6-d4d9-42da-9cf8-4272fe67393a): COMMIT; {"timestamp":"2023-08-15T06:59:07.763Z"}
info: User Already exists {"timestamp":"2023-08-15T06:59:07.765Z"}
info: User Created {"timestamp":"2023-08-15T06:59:07.766Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:07.769Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:07.786Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:07.792Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:07.798Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:07.806Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:07.807Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:07.809Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:07.810Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:07.812Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:07.814Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:07.825Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:07.831Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:07.832Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:07.838Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:07.842Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:07.843Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:07.853Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:07.856Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:07.857Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:07.868Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:59:11.785Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:59:11.886Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:59:11.887Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:59:11.887Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:59:11.888Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:59:11.909Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:59:11.910Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:59:11.959Z"}
debug: Executing (ee1f02db-dace-42a5-91e8-d6b79130dd44): START TRANSACTION; {"timestamp":"2023-08-15T06:59:11.961Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:11.962Z"}
debug: Executing (ee1f02db-dace-42a5-91e8-d6b79130dd44): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:59:11.969Z"}
debug: Executing (ee1f02db-dace-42a5-91e8-d6b79130dd44): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_6aaf9e5d628347e0a3cc3f1e675d4577$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:59:11.975 +00:00','2023-08-15 06:59:11.975 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_6aaf9e5d628347e0a3cc3f1e675d4577$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:59:11.979Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:11.980Z"}
debug: Executing (ee1f02db-dace-42a5-91e8-d6b79130dd44): COMMIT; {"timestamp":"2023-08-15T06:59:11.987Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:11.988Z"}
info: User Already exists {"timestamp":"2023-08-15T06:59:11.989Z"}
info: User Created {"timestamp":"2023-08-15T06:59:11.990Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:11.993Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:11.998Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:12.014Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:12.022Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:12.028Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:12.037Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:12.039Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:12.040Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:12.041Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:12.042Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:12.045Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:12.055Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:12.061Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:12.063Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:12.069Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:12.072Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:12.074Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:12.083Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:12.086Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:12.088Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:12.097Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:59:13.716Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:59:13.831Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:59:13.832Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:59:13.832Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:59:13.833Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:59:13.854Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:59:13.855Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:59:13.920Z"}
debug: Executing (5ecf633b-9370-4e72-9775-f6651bd7c202): START TRANSACTION; {"timestamp":"2023-08-15T06:59:13.921Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:13.922Z"}
debug: Executing (5ecf633b-9370-4e72-9775-f6651bd7c202): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:59:13.928Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:13.933Z"}
debug: Executing (5ecf633b-9370-4e72-9775-f6651bd7c202): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_dab1db5509984fdcacb3b627c6116fa0$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:59:13.937 +00:00','2023-08-15 06:59:13.937 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_dab1db5509984fdcacb3b627c6116fa0$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:59:13.942Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:13.944Z"}
debug: Executing (5ecf633b-9370-4e72-9775-f6651bd7c202): COMMIT; {"timestamp":"2023-08-15T06:59:13.950Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:13.952Z"}
info: User Already exists {"timestamp":"2023-08-15T06:59:13.953Z"}
info: User Created {"timestamp":"2023-08-15T06:59:13.954Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:13.959Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:13.980Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:13.991Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:14.001Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:14.012Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:14.013Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:14.015Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:14.017Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:14.020Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:14.025Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:14.039Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:14.047Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:14.049Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:14.057Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:14.061Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:14.063Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:14.077Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:14.080Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:14.083Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:14.096Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T06:59:29.633Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:59:29.752Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T06:59:29.753Z"}
info: ================================================================ {"timestamp":"2023-08-15T06:59:29.754Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T06:59:29.754Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T06:59:29.778Z"}
info: Redis store initialized {"timestamp":"2023-08-15T06:59:29.778Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T06:59:29.830Z"}
debug: Executing (fc180e6d-9146-4134-8dd2-e80f14712269): START TRANSACTION; {"timestamp":"2023-08-15T06:59:29.831Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:29.834Z"}
debug: Executing (fc180e6d-9146-4134-8dd2-e80f14712269): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T06:59:29.844Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:29.849Z"}
debug: Executing (fc180e6d-9146-4134-8dd2-e80f14712269): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_6aa5be921acb44bcbcd0c1604142fda5$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 06:59:29.855 +00:00','2023-08-15 06:59:29.855 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_6aa5be921acb44bcbcd0c1604142fda5$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T06:59:29.861Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:29.863Z"}
debug: Executing (fc180e6d-9146-4134-8dd2-e80f14712269): COMMIT; {"timestamp":"2023-08-15T06:59:29.870Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:29.871Z"}
info: User Already exists {"timestamp":"2023-08-15T06:59:29.872Z"}
info: User Created {"timestamp":"2023-08-15T06:59:29.873Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:29.877Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:29.900Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:29.909Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T06:59:29.919Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:29.929Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:29.931Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:29.933Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:29.935Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T06:59:29.938Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:29.941Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:29.955Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T06:59:29.963Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:29.965Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:29.973Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T06:59:29.979Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:29.981Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:29.997Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T06:59:30.002Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T06:59:30.004Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T06:59:30.019Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:02:03.889Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:02:03.984Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:02:03.985Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:02:03.985Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:02:03.986Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:02:04.003Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:02:04.003Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:02:04.041Z"}
debug: Executing (5f3a6739-087f-4ea6-96df-98a8888d3f60): START TRANSACTION; {"timestamp":"2023-08-15T07:02:04.044Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:04.045Z"}
debug: Executing (5f3a6739-087f-4ea6-96df-98a8888d3f60): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:02:04.050Z"}
debug: Executing (5f3a6739-087f-4ea6-96df-98a8888d3f60): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_341081499cc248738c8b268ff46e8260$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:02:04.055 +00:00','2023-08-15 07:02:04.055 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_341081499cc248738c8b268ff46e8260$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:02:04.059Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:04.060Z"}
debug: Executing (5f3a6739-087f-4ea6-96df-98a8888d3f60): COMMIT; {"timestamp":"2023-08-15T07:02:04.065Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:04.066Z"}
info: User Already exists {"timestamp":"2023-08-15T07:02:04.067Z"}
info: User Created {"timestamp":"2023-08-15T07:02:04.067Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:04.070Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:04.075Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:04.091Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:04.098Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:04.104Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:04.111Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:04.113Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:04.114Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:04.115Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:04.116Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:04.118Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:04.128Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:04.134Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:04.135Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:04.140Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:04.145Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:04.146Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:04.156Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:04.159Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:04.160Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:04.170Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:02:09.166Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:02:09.263Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:02:09.263Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:02:09.264Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:02:09.265Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:02:09.281Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:02:09.282Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:02:09.322Z"}
debug: Executing (521ee291-60b2-4b0f-9cbb-d5658181c2c9): START TRANSACTION; {"timestamp":"2023-08-15T07:02:09.323Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:09.324Z"}
debug: Executing (521ee291-60b2-4b0f-9cbb-d5658181c2c9): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:02:09.330Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:09.333Z"}
debug: Executing (521ee291-60b2-4b0f-9cbb-d5658181c2c9): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e56ed97a7d574203bf2bbea0b5f74ebf$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:02:09.335 +00:00','2023-08-15 07:02:09.335 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e56ed97a7d574203bf2bbea0b5f74ebf$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:02:09.339Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:09.341Z"}
debug: Executing (521ee291-60b2-4b0f-9cbb-d5658181c2c9): COMMIT; {"timestamp":"2023-08-15T07:02:09.345Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:09.346Z"}
info: User Already exists {"timestamp":"2023-08-15T07:02:09.347Z"}
info: User Created {"timestamp":"2023-08-15T07:02:09.348Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:09.351Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:09.368Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:09.375Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:09.382Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:09.388Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:09.390Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:09.391Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:09.392Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:09.394Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:09.397Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:09.406Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:09.412Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:09.414Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:09.419Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:09.422Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:09.424Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:09.433Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:09.436Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:09.437Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:09.448Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:02:48.429Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:02:48.530Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:02:48.531Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:02:48.532Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:02:48.532Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:02:48.549Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:02:48.550Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:02:48.590Z"}
debug: Executing (d8569a37-703f-4c96-840f-9f9cfca734b5): START TRANSACTION; {"timestamp":"2023-08-15T07:02:48.591Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:48.592Z"}
debug: Executing (d8569a37-703f-4c96-840f-9f9cfca734b5): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:02:48.597Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:48.601Z"}
debug: Executing (d8569a37-703f-4c96-840f-9f9cfca734b5): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_cf1ff1da580c4fecbbd927dcebbc26fa$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:02:48.603 +00:00','2023-08-15 07:02:48.603 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_cf1ff1da580c4fecbbd927dcebbc26fa$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:02:48.607Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:48.609Z"}
debug: Executing (d8569a37-703f-4c96-840f-9f9cfca734b5): COMMIT; {"timestamp":"2023-08-15T07:02:48.613Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:48.614Z"}
info: User Already exists {"timestamp":"2023-08-15T07:02:48.615Z"}
info: User Created {"timestamp":"2023-08-15T07:02:48.615Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:48.619Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:48.635Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:48.643Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:02:48.649Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:48.656Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:48.658Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:48.659Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:48.660Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:02:48.662Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:48.664Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:48.674Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:02:48.680Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:48.681Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:48.687Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:02:48.691Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:48.693Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:48.703Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:02:48.705Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:02:48.707Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:02:48.717Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:03:00.971Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:03:01.067Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:03:01.068Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:03:01.069Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:03:01.069Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:03:01.085Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:03:01.086Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:03:01.125Z"}
debug: Executing (cef449d6-ee4f-49b6-af59-30ab1d4ee16a): START TRANSACTION; {"timestamp":"2023-08-15T07:03:01.127Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:01.128Z"}
debug: Executing (cef449d6-ee4f-49b6-af59-30ab1d4ee16a): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:03:01.133Z"}
debug: Executing (cef449d6-ee4f-49b6-af59-30ab1d4ee16a): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_186962fc88694a3da48151ba2ead9f08$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:03:01.138 +00:00','2023-08-15 07:03:01.138 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_186962fc88694a3da48151ba2ead9f08$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:03:01.142Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:01.143Z"}
debug: Executing (cef449d6-ee4f-49b6-af59-30ab1d4ee16a): COMMIT; {"timestamp":"2023-08-15T07:03:01.148Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:01.149Z"}
info: User Already exists {"timestamp":"2023-08-15T07:03:01.150Z"}
info: User Created {"timestamp":"2023-08-15T07:03:01.150Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:01.153Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:01.158Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:01.173Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:01.180Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:01.187Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:01.194Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:01.195Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:01.196Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:01.197Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:01.198Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:01.201Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:01.211Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:01.216Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:01.217Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:01.223Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:01.226Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:01.228Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:01.238Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:01.241Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:01.242Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:01.252Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:03:09.028Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:03:09.143Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:03:09.144Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:03:09.145Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:03:09.145Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:03:09.164Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:03:09.165Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:03:09.208Z"}
debug: Executing (9f863f1a-ae96-4940-8f27-2a57629149a5): START TRANSACTION; {"timestamp":"2023-08-15T07:03:09.209Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:09.210Z"}
debug: Executing (9f863f1a-ae96-4940-8f27-2a57629149a5): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:03:09.215Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:09.218Z"}
debug: Executing (9f863f1a-ae96-4940-8f27-2a57629149a5): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_69abf824897f41f5bfc224d5b6d76e22$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:03:09.220 +00:00','2023-08-15 07:03:09.220 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_69abf824897f41f5bfc224d5b6d76e22$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:03:09.227Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:09.228Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:09.232Z"}
debug: Executing (9f863f1a-ae96-4940-8f27-2a57629149a5): COMMIT; {"timestamp":"2023-08-15T07:03:09.233Z"}
info: User Already exists {"timestamp":"2023-08-15T07:03:09.235Z"}
info: User Created {"timestamp":"2023-08-15T07:03:09.236Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:09.240Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:09.260Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:09.267Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:09.274Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:09.281Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:09.282Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:09.283Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:09.284Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:09.286Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:09.288Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:09.299Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:09.304Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:09.306Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:09.312Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:09.316Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:09.317Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:09.328Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:09.330Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:09.331Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:09.342Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:03:16.989Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:03:17.103Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:03:17.104Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:03:17.105Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:03:17.106Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:03:17.129Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:03:17.130Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:03:17.180Z"}
debug: Executing (4d293937-68a3-4452-92a9-4b36684ab906): START TRANSACTION; {"timestamp":"2023-08-15T07:03:17.181Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:17.182Z"}
debug: Executing (4d293937-68a3-4452-92a9-4b36684ab906): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:03:17.187Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:17.192Z"}
debug: Executing (4d293937-68a3-4452-92a9-4b36684ab906): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_daa45a17d8d64592a0825bf7c172fc40$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:03:17.194 +00:00','2023-08-15 07:03:17.194 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_daa45a17d8d64592a0825bf7c172fc40$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:03:17.198Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:17.200Z"}
debug: Executing (4d293937-68a3-4452-92a9-4b36684ab906): COMMIT; {"timestamp":"2023-08-15T07:03:17.204Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:17.205Z"}
info: User Already exists {"timestamp":"2023-08-15T07:03:17.206Z"}
info: User Created {"timestamp":"2023-08-15T07:03:17.206Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:17.210Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:17.227Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:17.234Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:03:17.242Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:17.249Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:17.250Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:17.251Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:17.252Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:03:17.253Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:17.257Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:17.266Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:03:17.272Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:17.274Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:17.280Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:03:17.283Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:17.284Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:17.295Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:03:17.298Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:03:17.299Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:03:17.310Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:04:33.061Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:04:33.164Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:04:33.164Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:04:33.165Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:04:33.166Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:04:33.180Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:04:33.181Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:04:33.220Z"}
debug: Executing (17c47a2d-ab9f-4516-bdcd-bc51f9d41b24): START TRANSACTION; {"timestamp":"2023-08-15T07:04:33.221Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:04:33.222Z"}
debug: Executing (17c47a2d-ab9f-4516-bdcd-bc51f9d41b24): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:04:33.227Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:04:33.231Z"}
debug: Executing (17c47a2d-ab9f-4516-bdcd-bc51f9d41b24): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_63f6f6cbcedc41a193be03228e155627$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:04:33.233 +00:00','2023-08-15 07:04:33.233 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_63f6f6cbcedc41a193be03228e155627$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:04:33.238Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:04:33.239Z"}
debug: Executing (17c47a2d-ab9f-4516-bdcd-bc51f9d41b24): COMMIT; {"timestamp":"2023-08-15T07:04:33.244Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:04:33.245Z"}
info: User Already exists {"timestamp":"2023-08-15T07:04:33.246Z"}
info: User Created {"timestamp":"2023-08-15T07:04:33.246Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:04:33.250Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:04:33.268Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:04:33.276Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:04:33.282Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:04:33.290Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:04:33.291Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:04:33.292Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:04:33.293Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:04:33.294Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:04:33.297Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:04:33.309Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:04:33.316Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:04:33.318Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:04:33.324Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:04:33.327Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:04:33.329Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:04:33.339Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:04:33.342Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:04:33.343Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:04:33.354Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:04:57.937Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:04:58.054Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:04:58.055Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:04:58.055Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:04:58.056Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:04:58.070Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:04:58.071Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:04:58.115Z"}
debug: Executing (ad6095c0-9919-4558-9e84-a341dced4772): START TRANSACTION; {"timestamp":"2023-08-15T07:04:58.118Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:04:58.119Z"}
debug: Executing (ad6095c0-9919-4558-9e84-a341dced4772): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:04:58.127Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:04:58.132Z"}
debug: Executing (ad6095c0-9919-4558-9e84-a341dced4772): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_2978ac3dec464eb7a1e69f7b2d586593$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:04:58.134 +00:00','2023-08-15 07:04:58.134 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_2978ac3dec464eb7a1e69f7b2d586593$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:04:58.139Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:04:58.140Z"}
debug: Executing (ad6095c0-9919-4558-9e84-a341dced4772): COMMIT; {"timestamp":"2023-08-15T07:04:58.146Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:04:58.147Z"}
info: User Already exists {"timestamp":"2023-08-15T07:04:58.148Z"}
info: User Created {"timestamp":"2023-08-15T07:04:58.148Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:04:58.152Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:04:58.169Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:04:58.175Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:04:58.181Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:04:58.189Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:04:58.191Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:04:58.193Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:04:58.194Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:04:58.196Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:04:58.200Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:04:58.211Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:04:58.218Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:04:58.219Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:04:58.225Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:04:58.229Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:04:58.230Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:04:58.240Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:04:58.243Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:04:58.245Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:04:58.255Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:05:00.741Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:05:00.873Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:05:00.874Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:05:00.874Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:05:00.875Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:05:00.895Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:05:00.896Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:05:00.941Z"}
debug: Executing (39ac6071-3a86-4a0d-b2aa-8f88bba2a951): START TRANSACTION; {"timestamp":"2023-08-15T07:05:00.942Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:05:00.943Z"}
debug: Executing (39ac6071-3a86-4a0d-b2aa-8f88bba2a951): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:05:00.950Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:05:00.953Z"}
debug: Executing (39ac6071-3a86-4a0d-b2aa-8f88bba2a951): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_a8f1a2ccedae433babfba7828d845e7a$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:05:00.956 +00:00','2023-08-15 07:05:00.956 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_a8f1a2ccedae433babfba7828d845e7a$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:05:00.960Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:05:00.961Z"}
debug: Executing (39ac6071-3a86-4a0d-b2aa-8f88bba2a951): COMMIT; {"timestamp":"2023-08-15T07:05:00.966Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:05:00.967Z"}
info: User Already exists {"timestamp":"2023-08-15T07:05:00.968Z"}
info: User Created {"timestamp":"2023-08-15T07:05:00.968Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:05:00.972Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:05:00.989Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:05:00.996Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:05:01.003Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:05:01.010Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:05:01.011Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:05:01.012Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:05:01.013Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:05:01.014Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:05:01.018Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:05:01.028Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:05:01.035Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:05:01.036Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:05:01.042Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:05:01.045Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:05:01.046Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:05:01.063Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:05:01.066Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:05:01.068Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:05:01.078Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:05:13.080Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:05:13.211Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:05:13.212Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:05:13.212Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:05:13.213Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:05:13.238Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:05:13.238Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:05:13.303Z"}
debug: Executing (f0d8e07b-410e-4425-b7fb-556c98449a69): START TRANSACTION; {"timestamp":"2023-08-15T07:05:13.304Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:05:13.306Z"}
debug: Executing (f0d8e07b-410e-4425-b7fb-556c98449a69): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:05:13.315Z"}
debug: Executing (f0d8e07b-410e-4425-b7fb-556c98449a69): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_ffb73138e39d46eab5a9601284cf34f2$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:05:13.324 +00:00','2023-08-15 07:05:13.324 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_ffb73138e39d46eab5a9601284cf34f2$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:05:13.329Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:05:13.331Z"}
debug: Executing (f0d8e07b-410e-4425-b7fb-556c98449a69): COMMIT; {"timestamp":"2023-08-15T07:05:13.338Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:05:13.341Z"}
info: User Already exists {"timestamp":"2023-08-15T07:05:13.341Z"}
info: User Created {"timestamp":"2023-08-15T07:05:13.342Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:05:13.347Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:05:13.354Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:05:13.380Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:05:13.393Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:05:13.404Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:05:13.415Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:05:13.418Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:05:13.419Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:05:13.421Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:05:13.424Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:05:13.430Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:05:13.444Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:05:13.453Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:05:13.456Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:05:13.464Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:05:13.469Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:05:13.472Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:05:13.487Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:05:13.492Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:05:13.494Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:05:13.511Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:07:58.632Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:07:58.732Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:07:58.733Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:07:58.734Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:07:58.734Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:07:58.751Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:07:58.751Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:07:58.799Z"}
debug: Executing (843d4f94-10f8-4f17-8749-0bf0224eaf23): START TRANSACTION; {"timestamp":"2023-08-15T07:07:58.800Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:07:58.801Z"}
debug: Executing (843d4f94-10f8-4f17-8749-0bf0224eaf23): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:07:58.807Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:07:58.811Z"}
debug: Executing (843d4f94-10f8-4f17-8749-0bf0224eaf23): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_b51be80bd64640c4b586cf01a8f9c390$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:07:58.813 +00:00','2023-08-15 07:07:58.813 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_b51be80bd64640c4b586cf01a8f9c390$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:07:58.817Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:07:58.819Z"}
debug: Executing (843d4f94-10f8-4f17-8749-0bf0224eaf23): COMMIT; {"timestamp":"2023-08-15T07:07:58.823Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:07:58.824Z"}
info: User Already exists {"timestamp":"2023-08-15T07:07:58.826Z"}
info: User Created {"timestamp":"2023-08-15T07:07:58.826Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:07:58.830Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:07:58.851Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:07:58.859Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:07:58.867Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:07:58.874Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:07:58.876Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:07:58.878Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:07:58.880Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:07:58.882Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:07:58.885Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:07:58.895Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:07:58.902Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:07:58.904Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:07:58.911Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:07:58.915Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:07:58.917Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:07:58.927Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:07:58.929Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:07:58.931Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:07:58.942Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:08:12.822Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:08:12.923Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:08:12.923Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:08:12.924Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:08:12.925Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:08:12.943Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:08:12.944Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:08:12.995Z"}
debug: Executing (d929cf37-7331-4692-a93f-e38c45a7f873): START TRANSACTION; {"timestamp":"2023-08-15T07:08:12.996Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:12.997Z"}
debug: Executing (d929cf37-7331-4692-a93f-e38c45a7f873): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:08:13.002Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:13.006Z"}
debug: Executing (d929cf37-7331-4692-a93f-e38c45a7f873): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_bec956d23ecd465ab906e1828c35e3de$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:08:13.007 +00:00','2023-08-15 07:08:13.007 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_bec956d23ecd465ab906e1828c35e3de$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:08:13.013Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:13.014Z"}
debug: Executing (d929cf37-7331-4692-a93f-e38c45a7f873): COMMIT; {"timestamp":"2023-08-15T07:08:13.019Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:13.019Z"}
info: User Already exists {"timestamp":"2023-08-15T07:08:13.021Z"}
info: User Created {"timestamp":"2023-08-15T07:08:13.021Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:13.027Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:13.044Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:13.051Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:13.058Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:13.067Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:13.068Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:13.069Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:13.070Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:13.071Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:13.074Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:13.084Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:13.090Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:13.091Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:13.097Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:13.100Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:13.102Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:13.113Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:13.115Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:13.117Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:13.127Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:08:47.148Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:08:47.244Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:08:47.245Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:08:47.246Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:08:47.246Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:08:47.263Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:08:47.264Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:08:47.306Z"}
debug: Executing (2aad3eb8-afc1-4d5e-bdce-33b28992a6dd): START TRANSACTION; {"timestamp":"2023-08-15T07:08:47.307Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:47.307Z"}
debug: Executing (2aad3eb8-afc1-4d5e-bdce-33b28992a6dd): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:08:47.314Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:47.317Z"}
debug: Executing (2aad3eb8-afc1-4d5e-bdce-33b28992a6dd): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_25bf28bd732748359f65845fa634523d$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:08:47.319 +00:00','2023-08-15 07:08:47.319 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_25bf28bd732748359f65845fa634523d$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:08:47.324Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:47.325Z"}
debug: Executing (2aad3eb8-afc1-4d5e-bdce-33b28992a6dd): COMMIT; {"timestamp":"2023-08-15T07:08:47.331Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:47.331Z"}
info: User Already exists {"timestamp":"2023-08-15T07:08:47.333Z"}
info: User Created {"timestamp":"2023-08-15T07:08:47.333Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:47.336Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:47.353Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:47.360Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:47.367Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:47.374Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:47.375Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:47.377Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:47.378Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:47.380Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:47.383Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:47.394Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:47.401Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:47.402Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:47.408Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:47.412Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:47.414Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:47.424Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:47.427Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:47.429Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:47.439Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:08:56.561Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:08:56.665Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:08:56.666Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:08:56.666Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:08:56.667Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:08:56.684Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:08:56.685Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:08:56.725Z"}
debug: Executing (fe9c67c4-7275-47c1-9be1-4a7d07f5df8e): START TRANSACTION; {"timestamp":"2023-08-15T07:08:56.726Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:56.727Z"}
debug: Executing (fe9c67c4-7275-47c1-9be1-4a7d07f5df8e): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:08:56.733Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:56.737Z"}
debug: Executing (fe9c67c4-7275-47c1-9be1-4a7d07f5df8e): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_48f1686276bb45cba8177c51c7fb2e4e$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:08:56.739 +00:00','2023-08-15 07:08:56.739 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_48f1686276bb45cba8177c51c7fb2e4e$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:08:56.745Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:56.746Z"}
debug: Executing (fe9c67c4-7275-47c1-9be1-4a7d07f5df8e): COMMIT; {"timestamp":"2023-08-15T07:08:56.751Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:56.751Z"}
info: User Already exists {"timestamp":"2023-08-15T07:08:56.753Z"}
info: User Created {"timestamp":"2023-08-15T07:08:56.753Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:56.756Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:56.772Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:56.779Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:08:56.785Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:56.792Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:56.794Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:56.795Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:56.797Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:08:56.798Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:56.801Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:56.811Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:08:56.817Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:56.818Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:56.824Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:08:56.827Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:56.829Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:56.838Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:08:56.841Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:08:56.844Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:08:56.854Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:09:06.247Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:09:06.344Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:09:06.345Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:09:06.346Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:09:06.347Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:09:06.366Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:09:06.367Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:09:06.405Z"}
debug: Executing (a1c2e1e7-1b42-40b5-a19c-0865d6fb9f3d): START TRANSACTION; {"timestamp":"2023-08-15T07:09:06.406Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:09:06.407Z"}
debug: Executing (a1c2e1e7-1b42-40b5-a19c-0865d6fb9f3d): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:09:06.413Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:09:06.417Z"}
debug: Executing (a1c2e1e7-1b42-40b5-a19c-0865d6fb9f3d): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_690b142af4e54ac2805c12f18bf25853$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:09:06.419 +00:00','2023-08-15 07:09:06.419 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_690b142af4e54ac2805c12f18bf25853$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:09:06.423Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:09:06.425Z"}
debug: Executing (a1c2e1e7-1b42-40b5-a19c-0865d6fb9f3d): COMMIT; {"timestamp":"2023-08-15T07:09:06.430Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:09:06.430Z"}
info: User Already exists {"timestamp":"2023-08-15T07:09:06.432Z"}
info: User Created {"timestamp":"2023-08-15T07:09:06.432Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:09:06.436Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:09:06.453Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:09:06.461Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:09:06.472Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:09:06.482Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:09:06.484Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:09:06.486Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:09:06.488Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:09:06.490Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:09:06.495Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:09:06.509Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:09:06.517Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:09:06.547Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:09:06.555Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:09:06.561Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:09:06.564Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:09:06.582Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:09:06.586Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:09:06.587Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:09:06.600Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:09:48.106Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:09:48.215Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:09:48.216Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:09:48.216Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:09:48.217Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:09:48.235Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:09:48.235Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:09:48.278Z"}
debug: Executing (c1384eb8-3f2c-4cb7-9674-6a95b2e50598): START TRANSACTION; {"timestamp":"2023-08-15T07:09:48.279Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:09:48.280Z"}
debug: Executing (c1384eb8-3f2c-4cb7-9674-6a95b2e50598): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:09:48.285Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:09:48.288Z"}
debug: Executing (c1384eb8-3f2c-4cb7-9674-6a95b2e50598): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_c7a3c81dfc7749cbac1fa9a82ada9c3f$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:09:48.291 +00:00','2023-08-15 07:09:48.291 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_c7a3c81dfc7749cbac1fa9a82ada9c3f$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:09:48.296Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:09:48.297Z"}
debug: Executing (c1384eb8-3f2c-4cb7-9674-6a95b2e50598): COMMIT; {"timestamp":"2023-08-15T07:09:48.301Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:09:48.302Z"}
info: User Already exists {"timestamp":"2023-08-15T07:09:48.303Z"}
info: User Created {"timestamp":"2023-08-15T07:09:48.303Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:09:48.307Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:09:48.324Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:09:48.331Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:09:48.338Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:09:48.351Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:09:48.371Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:09:48.372Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:09:48.374Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:09:48.377Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:09:48.380Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:09:48.394Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:09:48.400Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:09:48.402Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:09:48.409Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:09:48.413Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:09:48.415Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:09:48.426Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:09:48.430Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:09:48.431Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:09:48.444Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:10:27.943Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:10:28.047Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:10:28.048Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:10:28.048Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:10:28.049Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:10:28.066Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:10:28.067Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:10:28.108Z"}
debug: Executing (b855b06a-5c88-40fa-be6b-77f0bc14d6ab): START TRANSACTION; {"timestamp":"2023-08-15T07:10:28.109Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:10:28.110Z"}
debug: Executing (b855b06a-5c88-40fa-be6b-77f0bc14d6ab): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:10:28.115Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:10:28.119Z"}
debug: Executing (b855b06a-5c88-40fa-be6b-77f0bc14d6ab): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_93cd2e61529249929c97d509a09d9647$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:10:28.120 +00:00','2023-08-15 07:10:28.120 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_93cd2e61529249929c97d509a09d9647$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:10:28.126Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:10:28.127Z"}
debug: Executing (b855b06a-5c88-40fa-be6b-77f0bc14d6ab): COMMIT; {"timestamp":"2023-08-15T07:10:28.131Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:10:28.132Z"}
info: User Already exists {"timestamp":"2023-08-15T07:10:28.133Z"}
info: User Created {"timestamp":"2023-08-15T07:10:28.133Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:10:28.136Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:10:28.153Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:10:28.160Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:10:28.167Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:10:28.174Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:10:28.176Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:10:28.177Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:10:28.178Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:10:28.180Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:10:28.182Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:10:28.194Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:10:28.200Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:10:28.201Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:10:28.210Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:10:28.213Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:10:28.215Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:10:28.225Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:10:28.227Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:10:28.229Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:10:28.239Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:11:36.876Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:11:36.986Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:11:36.987Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:11:36.987Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:11:36.988Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:11:37.013Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:11:37.014Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:11:37.056Z"}
debug: Executing (911f3a42-2dea-4107-ba13-ab2dfead689a): START TRANSACTION; {"timestamp":"2023-08-15T07:11:37.056Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:11:37.057Z"}
debug: Executing (911f3a42-2dea-4107-ba13-ab2dfead689a): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:11:37.063Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:11:37.066Z"}
debug: Executing (911f3a42-2dea-4107-ba13-ab2dfead689a): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_a425aa9645764b148d37c46f3238fc74$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:11:37.068 +00:00','2023-08-15 07:11:37.068 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_a425aa9645764b148d37c46f3238fc74$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:11:37.072Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:11:37.074Z"}
debug: Executing (911f3a42-2dea-4107-ba13-ab2dfead689a): COMMIT; {"timestamp":"2023-08-15T07:11:37.078Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:11:37.079Z"}
info: User Already exists {"timestamp":"2023-08-15T07:11:37.080Z"}
info: User Created {"timestamp":"2023-08-15T07:11:37.081Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:11:37.084Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:11:37.099Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:11:37.106Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:11:37.113Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:11:37.120Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:11:37.121Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:11:37.123Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:11:37.124Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:11:37.126Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:11:37.129Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:11:37.139Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:11:37.144Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:11:37.146Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:11:37.151Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:11:37.154Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:11:37.156Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:11:37.165Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:11:37.168Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:11:37.169Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:11:37.179Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:12:07.111Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:07.209Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:12:07.210Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:07.211Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:12:07.211Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:12:07.231Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:12:07.232Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:12:07.289Z"}
debug: Executing (e565a34d-5ccb-4ef9-98fd-78bee37026c2): START TRANSACTION; {"timestamp":"2023-08-15T07:12:07.291Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:07.292Z"}
debug: Executing (e565a34d-5ccb-4ef9-98fd-78bee37026c2): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:12:07.299Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:07.303Z"}
debug: Executing (e565a34d-5ccb-4ef9-98fd-78bee37026c2): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_0aebc4b2c8c14af0b7a12acd5de4c786$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:12:07.307 +00:00','2023-08-15 07:12:07.307 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_0aebc4b2c8c14af0b7a12acd5de4c786$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:12:07.312Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:07.314Z"}
debug: Executing (e565a34d-5ccb-4ef9-98fd-78bee37026c2): COMMIT; {"timestamp":"2023-08-15T07:12:07.319Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:07.321Z"}
info: User Already exists {"timestamp":"2023-08-15T07:12:07.322Z"}
info: User Created {"timestamp":"2023-08-15T07:12:07.323Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:07.326Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:07.342Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:07.349Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:07.357Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:07.363Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:07.364Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:07.365Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:07.366Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:07.367Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:07.370Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:07.380Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:07.386Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:07.388Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:07.395Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:07.398Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:07.399Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:07.409Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:07.412Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:07.413Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:07.423Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:12:20.531Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:20.635Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:12:20.636Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:20.637Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:12:20.638Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:12:20.657Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:12:20.658Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:12:20.699Z"}
debug: Executing (0eec8f15-4a38-4864-86de-3f4fd6332188): START TRANSACTION; {"timestamp":"2023-08-15T07:12:20.701Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:20.702Z"}
debug: Executing (0eec8f15-4a38-4864-86de-3f4fd6332188): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:12:20.710Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:20.713Z"}
debug: Executing (0eec8f15-4a38-4864-86de-3f4fd6332188): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_1c73ee266cf34fc38d7592ddbe4e4468$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:12:20.715 +00:00','2023-08-15 07:12:20.715 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_1c73ee266cf34fc38d7592ddbe4e4468$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:12:20.719Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:20.720Z"}
debug: Executing (0eec8f15-4a38-4864-86de-3f4fd6332188): COMMIT; {"timestamp":"2023-08-15T07:12:20.725Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:20.726Z"}
info: User Already exists {"timestamp":"2023-08-15T07:12:20.727Z"}
info: User Created {"timestamp":"2023-08-15T07:12:20.727Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:20.731Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:20.750Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:20.760Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:20.769Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:20.781Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:20.784Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:20.787Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:20.788Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:20.791Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:20.795Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:20.810Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:20.816Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:20.818Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:20.826Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:20.829Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:20.831Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:20.843Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:20.845Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:20.846Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:20.858Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:12:29.480Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:29.584Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:12:29.584Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:29.585Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:12:29.586Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:12:29.604Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:12:29.605Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:12:29.643Z"}
debug: Executing (c73d2907-dc6f-4459-99f8-b004b23cd86f): START TRANSACTION; {"timestamp":"2023-08-15T07:12:29.644Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:29.644Z"}
debug: Executing (c73d2907-dc6f-4459-99f8-b004b23cd86f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:12:29.650Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:29.654Z"}
debug: Executing (c73d2907-dc6f-4459-99f8-b004b23cd86f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_3e39931f0a044de88d4d438e88ca46a8$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:12:29.657 +00:00','2023-08-15 07:12:29.657 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_3e39931f0a044de88d4d438e88ca46a8$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:12:29.662Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:29.663Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:29.668Z"}
debug: Executing (c73d2907-dc6f-4459-99f8-b004b23cd86f): COMMIT; {"timestamp":"2023-08-15T07:12:29.669Z"}
info: User Already exists {"timestamp":"2023-08-15T07:12:29.671Z"}
info: User Created {"timestamp":"2023-08-15T07:12:29.672Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:29.675Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:29.690Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:29.697Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:29.704Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:29.711Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:29.712Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:29.713Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:29.714Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:29.715Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:29.717Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:29.727Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:29.732Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:29.734Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:29.740Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:29.743Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:29.744Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:29.754Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:29.757Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:29.759Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:29.771Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:12:48.685Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:48.784Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:12:48.785Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:48.785Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:12:48.786Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:12:48.804Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:12:48.805Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:12:48.843Z"}
debug: Executing (f77dcfca-64d1-4ebd-ac79-5110eea77be0): START TRANSACTION; {"timestamp":"2023-08-15T07:12:48.844Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:48.845Z"}
debug: Executing (f77dcfca-64d1-4ebd-ac79-5110eea77be0): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:12:48.850Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:48.854Z"}
debug: Executing (f77dcfca-64d1-4ebd-ac79-5110eea77be0): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_8da9bdb6a90749f39c3f1e1b703b4a29$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:12:48.856 +00:00','2023-08-15 07:12:48.856 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_8da9bdb6a90749f39c3f1e1b703b4a29$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:12:48.860Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:48.861Z"}
debug: Executing (f77dcfca-64d1-4ebd-ac79-5110eea77be0): COMMIT; {"timestamp":"2023-08-15T07:12:48.865Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:48.866Z"}
info: User Already exists {"timestamp":"2023-08-15T07:12:48.867Z"}
info: User Created {"timestamp":"2023-08-15T07:12:48.868Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:48.871Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:48.887Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:48.894Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:48.900Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:48.907Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:48.909Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:48.910Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:48.911Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:48.912Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:48.914Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:48.925Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:48.931Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:48.932Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:48.938Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:48.941Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:48.942Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:48.951Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:48.954Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:48.955Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:48.965Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:12:57.195Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:57.296Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:12:57.297Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:57.298Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:12:57.298Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:12:57.315Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:12:57.316Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:12:57.359Z"}
debug: Executing (89f4665d-1e14-4412-8c36-90533a026a3a): START TRANSACTION; {"timestamp":"2023-08-15T07:12:57.360Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:57.360Z"}
debug: Executing (89f4665d-1e14-4412-8c36-90533a026a3a): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:12:57.365Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:57.369Z"}
debug: Executing (89f4665d-1e14-4412-8c36-90533a026a3a): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_80d1a824cee3476bbf08c7ab7fc91011$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:12:57.372 +00:00','2023-08-15 07:12:57.372 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_80d1a824cee3476bbf08c7ab7fc91011$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:12:57.376Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:57.377Z"}
debug: Executing (89f4665d-1e14-4412-8c36-90533a026a3a): COMMIT; {"timestamp":"2023-08-15T07:12:57.381Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:57.382Z"}
info: User Already exists {"timestamp":"2023-08-15T07:12:57.383Z"}
info: User Created {"timestamp":"2023-08-15T07:12:57.384Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:57.388Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:57.406Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:57.412Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:57.420Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:57.428Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:57.429Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:57.430Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:57.431Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:57.433Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:57.437Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:57.447Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:57.453Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:57.455Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:57.460Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:57.463Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:57.465Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:57.475Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:57.478Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:57.479Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:57.491Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:12:59.054Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:59.165Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:12:59.165Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:12:59.166Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:12:59.166Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:12:59.183Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:12:59.184Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:12:59.224Z"}
debug: Executing (dcf5f508-5ea0-4858-bba2-cd8862a015c7): START TRANSACTION; {"timestamp":"2023-08-15T07:12:59.225Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:59.226Z"}
debug: Executing (dcf5f508-5ea0-4858-bba2-cd8862a015c7): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:12:59.234Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:59.235Z"}
debug: Executing (dcf5f508-5ea0-4858-bba2-cd8862a015c7): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_915d062c888d4085abe4205e03785f03$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:12:59.239 +00:00','2023-08-15 07:12:59.239 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_915d062c888d4085abe4205e03785f03$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:12:59.244Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:59.245Z"}
debug: Executing (dcf5f508-5ea0-4858-bba2-cd8862a015c7): COMMIT; {"timestamp":"2023-08-15T07:12:59.249Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:59.250Z"}
info: User Already exists {"timestamp":"2023-08-15T07:12:59.252Z"}
info: User Created {"timestamp":"2023-08-15T07:12:59.252Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:59.256Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:59.272Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:59.280Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:12:59.288Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:59.295Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:59.296Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:59.297Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:59.298Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:12:59.300Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:59.303Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:59.312Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:12:59.318Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:59.320Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:59.326Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:12:59.329Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:59.330Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:59.341Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:12:59.344Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:12:59.345Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:12:59.355Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:13:04.042Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:13:04.140Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:13:04.141Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:13:04.142Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:13:04.142Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:13:04.160Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:13:04.161Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:13:04.199Z"}
debug: Executing (03e9c9b7-e224-412b-8ca7-e62072c2927f): START TRANSACTION; {"timestamp":"2023-08-15T07:13:04.200Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:13:04.201Z"}
debug: Executing (03e9c9b7-e224-412b-8ca7-e62072c2927f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:13:04.207Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:13:04.211Z"}
debug: Executing (03e9c9b7-e224-412b-8ca7-e62072c2927f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_d10786f08dca4fc88d77d046892def5d$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:13:04.213 +00:00','2023-08-15 07:13:04.213 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_d10786f08dca4fc88d77d046892def5d$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:13:04.217Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:13:04.218Z"}
debug: Executing (03e9c9b7-e224-412b-8ca7-e62072c2927f): COMMIT; {"timestamp":"2023-08-15T07:13:04.223Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:13:04.223Z"}
info: User Already exists {"timestamp":"2023-08-15T07:13:04.225Z"}
info: User Created {"timestamp":"2023-08-15T07:13:04.225Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:13:04.228Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:13:04.245Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:13:04.252Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:13:04.259Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:13:04.266Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:13:04.268Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:13:04.270Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:13:04.271Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:13:04.273Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:13:04.275Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:13:04.286Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:13:04.292Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:13:04.293Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:13:04.299Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:13:04.303Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:13:04.305Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:13:04.315Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:13:04.318Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:13:04.319Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:13:04.330Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:13:06.295Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:13:06.417Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:13:06.418Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:13:06.419Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:13:06.420Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:13:06.445Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:13:06.445Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:13:06.501Z"}
debug: Executing (76cbfd79-2524-448c-94ed-ed17adecf482): START TRANSACTION; {"timestamp":"2023-08-15T07:13:06.505Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:13:06.506Z"}
debug: Executing (76cbfd79-2524-448c-94ed-ed17adecf482): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:13:06.512Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:13:06.517Z"}
debug: Executing (76cbfd79-2524-448c-94ed-ed17adecf482): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_7ae7098dab0e4ac8922b3ed63fd7d4b1$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:13:06.520 +00:00','2023-08-15 07:13:06.520 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_7ae7098dab0e4ac8922b3ed63fd7d4b1$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:13:06.526Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:13:06.527Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:13:06.532Z"}
debug: Executing (76cbfd79-2524-448c-94ed-ed17adecf482): COMMIT; {"timestamp":"2023-08-15T07:13:06.534Z"}
info: User Already exists {"timestamp":"2023-08-15T07:13:06.537Z"}
info: User Created {"timestamp":"2023-08-15T07:13:06.538Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:13:06.542Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:13:06.563Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:13:06.573Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:13:06.581Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:13:06.590Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:13:06.592Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:13:06.593Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:13:06.595Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:13:06.597Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:13:06.600Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:13:06.612Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:13:06.619Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:13:06.621Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:13:06.628Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:13:06.632Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:13:06.633Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:13:06.645Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:13:06.649Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:13:06.650Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:13:06.664Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:14:18.239Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:14:18.340Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:14:18.341Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:14:18.342Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:14:18.342Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:14:18.361Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:14:18.362Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:14:18.405Z"}
debug: Executing (dee22abd-5a72-4175-8d5e-0632df24b321): START TRANSACTION; {"timestamp":"2023-08-15T07:14:18.406Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:14:18.407Z"}
debug: Executing (dee22abd-5a72-4175-8d5e-0632df24b321): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:14:18.412Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:14:18.416Z"}
debug: Executing (dee22abd-5a72-4175-8d5e-0632df24b321): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_c34a92c111b44c5b831bbae20a7e8b7a$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:14:18.418 +00:00','2023-08-15 07:14:18.418 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_c34a92c111b44c5b831bbae20a7e8b7a$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:14:18.423Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:14:18.424Z"}
debug: Executing (dee22abd-5a72-4175-8d5e-0632df24b321): COMMIT; {"timestamp":"2023-08-15T07:14:18.428Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:14:18.429Z"}
info: User Already exists {"timestamp":"2023-08-15T07:14:18.430Z"}
info: User Created {"timestamp":"2023-08-15T07:14:18.430Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:14:18.434Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:14:18.449Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:14:18.456Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:14:18.462Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:14:18.470Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:14:18.471Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:14:18.472Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:14:18.473Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:14:18.474Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:14:18.477Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:14:18.487Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:14:18.493Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:14:18.494Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:14:18.500Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:14:18.504Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:14:18.505Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:14:18.514Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:14:18.517Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:14:18.518Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:14:18.529Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:14:56.287Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:14:56.414Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:14:56.415Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:14:56.415Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:14:56.416Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:14:56.433Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:14:56.434Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:14:56.485Z"}
debug: Executing (68b5db81-08d2-4fdc-9103-09dd42c375c7): START TRANSACTION; {"timestamp":"2023-08-15T07:14:56.487Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:14:56.488Z"}
debug: Executing (68b5db81-08d2-4fdc-9103-09dd42c375c7): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:14:56.494Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:14:56.497Z"}
debug: Executing (68b5db81-08d2-4fdc-9103-09dd42c375c7): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_ae5c3b748c734e7eab72ea862745cc29$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:14:56.501 +00:00','2023-08-15 07:14:56.501 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_ae5c3b748c734e7eab72ea862745cc29$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:14:56.506Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:14:56.507Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:14:56.512Z"}
debug: Executing (68b5db81-08d2-4fdc-9103-09dd42c375c7): COMMIT; {"timestamp":"2023-08-15T07:14:56.513Z"}
info: User Already exists {"timestamp":"2023-08-15T07:14:56.516Z"}
info: User Created {"timestamp":"2023-08-15T07:14:56.516Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:14:56.520Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:14:56.537Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:14:56.544Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:14:56.551Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:14:56.557Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:14:56.559Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:14:56.560Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:14:56.561Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:14:56.562Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:14:56.565Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:14:56.576Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:14:56.583Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:14:56.584Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:14:56.590Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:14:56.593Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:14:56.595Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:14:56.605Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:14:56.608Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:14:56.609Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:14:56.621Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:15:02.809Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:02.906Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:15:02.907Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:02.907Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:15:02.908Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:15:02.925Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:15:02.926Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:15:02.967Z"}
debug: Executing (215ce163-fac1-44d6-8838-894a64eb7376): START TRANSACTION; {"timestamp":"2023-08-15T07:15:02.968Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:02.969Z"}
debug: Executing (215ce163-fac1-44d6-8838-894a64eb7376): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:15:02.974Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:02.977Z"}
debug: Executing (215ce163-fac1-44d6-8838-894a64eb7376): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_ce04e090f9cb4799b04e93e32e76d221$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:15:02.979 +00:00','2023-08-15 07:15:02.979 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_ce04e090f9cb4799b04e93e32e76d221$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:15:02.984Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:02.985Z"}
debug: Executing (215ce163-fac1-44d6-8838-894a64eb7376): COMMIT; {"timestamp":"2023-08-15T07:15:02.989Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:02.990Z"}
info: User Already exists {"timestamp":"2023-08-15T07:15:02.991Z"}
info: User Created {"timestamp":"2023-08-15T07:15:02.992Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:02.995Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:03.011Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:03.018Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:03.025Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:03.032Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:03.034Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:03.035Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:03.036Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:03.037Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:03.040Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:03.050Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:03.055Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:03.057Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:03.062Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:03.066Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:03.067Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:03.079Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:03.083Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:03.085Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:03.095Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:15:12.674Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:12.809Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:15:12.810Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:12.810Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:15:12.811Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:15:12.831Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:15:12.831Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:15:12.872Z"}
debug: Executing (6bba572f-3037-4734-a952-ca00492f72df): START TRANSACTION; {"timestamp":"2023-08-15T07:15:12.875Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:12.876Z"}
debug: Executing (6bba572f-3037-4734-a952-ca00492f72df): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:15:12.882Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:12.886Z"}
debug: Executing (6bba572f-3037-4734-a952-ca00492f72df): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_faae0603260c4ecead10805c821b5a9c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:15:12.889 +00:00','2023-08-15 07:15:12.889 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_faae0603260c4ecead10805c821b5a9c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:15:12.894Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:12.896Z"}
debug: Executing (6bba572f-3037-4734-a952-ca00492f72df): COMMIT; {"timestamp":"2023-08-15T07:15:12.902Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:12.903Z"}
info: User Already exists {"timestamp":"2023-08-15T07:15:12.905Z"}
info: User Created {"timestamp":"2023-08-15T07:15:12.905Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:12.910Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:12.928Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:12.937Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:12.944Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:12.951Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:12.952Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:12.953Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:12.954Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:12.956Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:12.958Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:12.969Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:12.974Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:12.975Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:12.981Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:12.984Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:12.986Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:12.995Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:12.998Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:12.999Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:13.009Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:15:21.064Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:21.164Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:15:21.164Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:21.165Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:15:21.166Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:15:21.184Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:15:21.184Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:15:21.228Z"}
debug: Executing (4b7e349f-6c97-4a4f-ac81-8c0608c85f9e): START TRANSACTION; {"timestamp":"2023-08-15T07:15:21.229Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:21.230Z"}
debug: Executing (4b7e349f-6c97-4a4f-ac81-8c0608c85f9e): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:15:21.237Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:21.241Z"}
debug: Executing (4b7e349f-6c97-4a4f-ac81-8c0608c85f9e): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e32aa86e8be943d19da035faf11a2107$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:15:21.244 +00:00','2023-08-15 07:15:21.244 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e32aa86e8be943d19da035faf11a2107$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:15:21.251Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:21.253Z"}
debug: Executing (4b7e349f-6c97-4a4f-ac81-8c0608c85f9e): COMMIT; {"timestamp":"2023-08-15T07:15:21.257Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:21.257Z"}
info: User Already exists {"timestamp":"2023-08-15T07:15:21.259Z"}
info: User Created {"timestamp":"2023-08-15T07:15:21.259Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:21.263Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:21.279Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:21.286Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:21.293Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:21.300Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:21.301Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:21.302Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:21.303Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:21.305Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:21.307Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:21.317Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:21.323Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:21.324Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:21.330Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:21.333Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:21.334Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:21.344Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:21.347Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:21.348Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:21.359Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:15:27.352Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:27.481Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:15:27.482Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:27.483Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:15:27.483Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:15:27.504Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:15:27.504Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:15:27.554Z"}
debug: Executing (7a4f8639-713f-46c4-bd76-4c9a2361659c): START TRANSACTION; {"timestamp":"2023-08-15T07:15:27.555Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:27.556Z"}
debug: Executing (7a4f8639-713f-46c4-bd76-4c9a2361659c): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:15:27.561Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:27.567Z"}
debug: Executing (7a4f8639-713f-46c4-bd76-4c9a2361659c): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_39d75e162fcf4b17b84b5650fb091137$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:15:27.568 +00:00','2023-08-15 07:15:27.568 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_39d75e162fcf4b17b84b5650fb091137$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:15:27.573Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:27.574Z"}
debug: Executing (7a4f8639-713f-46c4-bd76-4c9a2361659c): COMMIT; {"timestamp":"2023-08-15T07:15:27.579Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:27.580Z"}
info: User Already exists {"timestamp":"2023-08-15T07:15:27.582Z"}
info: User Created {"timestamp":"2023-08-15T07:15:27.583Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:27.587Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:27.607Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:27.618Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:27.626Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:27.635Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:27.637Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:27.638Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:27.640Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:27.642Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:27.645Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:27.657Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:27.664Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:27.666Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:27.672Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:27.676Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:27.677Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:27.689Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:27.692Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:27.693Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:27.705Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:15:42.664Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:42.757Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:15:42.758Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:15:42.759Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:15:42.759Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:15:42.778Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:15:42.779Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:15:42.820Z"}
debug: Executing (8479fca0-9de7-451a-82f2-b553abb0b30b): START TRANSACTION; {"timestamp":"2023-08-15T07:15:42.821Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:42.822Z"}
debug: Executing (8479fca0-9de7-451a-82f2-b553abb0b30b): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:15:42.827Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:42.831Z"}
debug: Executing (8479fca0-9de7-451a-82f2-b553abb0b30b): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_fa5797f6ea794bcb95b9e93c3f6ca0de$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:15:42.833 +00:00','2023-08-15 07:15:42.833 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_fa5797f6ea794bcb95b9e93c3f6ca0de$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:15:42.838Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:42.840Z"}
debug: Executing (8479fca0-9de7-451a-82f2-b553abb0b30b): COMMIT; {"timestamp":"2023-08-15T07:15:42.844Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:42.845Z"}
info: User Already exists {"timestamp":"2023-08-15T07:15:42.846Z"}
info: User Created {"timestamp":"2023-08-15T07:15:42.847Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:42.850Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:42.867Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:42.874Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:15:42.881Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:42.888Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:42.889Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:42.890Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:42.891Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:15:42.893Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:42.896Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:42.906Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:15:42.911Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:42.913Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:42.919Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:15:42.922Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:42.924Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:42.933Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:15:42.936Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:15:42.937Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:15:42.947Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:16:06.586Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:16:06.682Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:16:06.683Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:16:06.683Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:16:06.684Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:16:06.701Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:16:06.701Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:16:06.741Z"}
debug: Executing (f37e6f4e-6a9e-49a8-bf7e-3b3693919602): START TRANSACTION; {"timestamp":"2023-08-15T07:16:06.742Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:16:06.742Z"}
debug: Executing (f37e6f4e-6a9e-49a8-bf7e-3b3693919602): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:16:06.749Z"}
debug: Executing (f37e6f4e-6a9e-49a8-bf7e-3b3693919602): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_5872985baea645dfb5415650d01e52c6$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:16:06.755 +00:00','2023-08-15 07:16:06.755 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_5872985baea645dfb5415650d01e52c6$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:16:06.759Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:16:06.760Z"}
debug: Executing (f37e6f4e-6a9e-49a8-bf7e-3b3693919602): COMMIT; {"timestamp":"2023-08-15T07:16:06.766Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:16:06.766Z"}
info: User Already exists {"timestamp":"2023-08-15T07:16:06.768Z"}
info: User Created {"timestamp":"2023-08-15T07:16:06.768Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:16:06.771Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:16:06.776Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:16:06.791Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:16:06.799Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:16:06.805Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:16:06.813Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:16:06.815Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:16:06.816Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:16:06.817Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:16:06.819Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:16:06.822Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:16:06.833Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:16:06.839Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:16:06.841Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:16:06.847Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:16:06.850Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:16:06.852Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:16:06.862Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:16:06.864Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:16:06.866Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:16:06.876Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:17:04.493Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:04.589Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:17:04.590Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:04.591Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:17:04.592Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:17:04.610Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:17:04.611Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:17:04.651Z"}
debug: Executing (6c89f1d6-e342-40f8-9720-942b3cceb848): START TRANSACTION; {"timestamp":"2023-08-15T07:17:04.652Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:04.652Z"}
debug: Executing (6c89f1d6-e342-40f8-9720-942b3cceb848): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:17:04.657Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:04.661Z"}
debug: Executing (6c89f1d6-e342-40f8-9720-942b3cceb848): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_5cc09194c28c4f9f914c6bc34a14e81d$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:17:04.663 +00:00','2023-08-15 07:17:04.663 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_5cc09194c28c4f9f914c6bc34a14e81d$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:17:04.667Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:04.668Z"}
debug: Executing (6c89f1d6-e342-40f8-9720-942b3cceb848): COMMIT; {"timestamp":"2023-08-15T07:17:04.672Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:04.673Z"}
info: User Already exists {"timestamp":"2023-08-15T07:17:04.674Z"}
info: User Created {"timestamp":"2023-08-15T07:17:04.675Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:04.679Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:04.695Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:04.702Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:04.709Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:04.716Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:04.717Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:04.718Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:04.719Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:04.720Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:04.723Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:04.733Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:04.738Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:04.739Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:04.745Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:04.748Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:04.750Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:04.759Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:04.762Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:04.763Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:04.774Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:17:10.585Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:10.686Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:17:10.686Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:10.687Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:17:10.688Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:17:10.705Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:17:10.706Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:17:10.745Z"}
debug: Executing (9f023d68-8ac7-429b-868f-93a9f96b31dd): START TRANSACTION; {"timestamp":"2023-08-15T07:17:10.746Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:10.747Z"}
debug: Executing (9f023d68-8ac7-429b-868f-93a9f96b31dd): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:17:10.753Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:10.756Z"}
debug: Executing (9f023d68-8ac7-429b-868f-93a9f96b31dd): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_48a7e29fd0584e06adc2415096b6b66d$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:17:10.759 +00:00','2023-08-15 07:17:10.759 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_48a7e29fd0584e06adc2415096b6b66d$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:17:10.765Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:10.766Z"}
debug: Executing (9f023d68-8ac7-429b-868f-93a9f96b31dd): COMMIT; {"timestamp":"2023-08-15T07:17:10.771Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:10.772Z"}
info: User Already exists {"timestamp":"2023-08-15T07:17:10.773Z"}
info: User Created {"timestamp":"2023-08-15T07:17:10.774Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:10.777Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:10.794Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:10.800Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:10.807Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:10.814Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:10.815Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:10.816Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:10.817Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:10.818Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:10.821Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:10.831Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:10.837Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:10.838Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:10.844Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:10.847Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:10.849Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:10.859Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:10.862Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:10.863Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:10.873Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:17:16.997Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:17.094Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:17:17.095Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:17.095Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:17:17.096Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:17:17.114Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:17:17.115Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:17:17.154Z"}
debug: Executing (b332e277-d5fa-486a-ad9d-cc7d96c0f62d): START TRANSACTION; {"timestamp":"2023-08-15T07:17:17.155Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:17.155Z"}
debug: Executing (b332e277-d5fa-486a-ad9d-cc7d96c0f62d): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:17:17.162Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:17.165Z"}
debug: Executing (b332e277-d5fa-486a-ad9d-cc7d96c0f62d): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_11efd7ac5a2a44008209f196d846085c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:17:17.167 +00:00','2023-08-15 07:17:17.167 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_11efd7ac5a2a44008209f196d846085c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:17:17.172Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:17.173Z"}
debug: Executing (b332e277-d5fa-486a-ad9d-cc7d96c0f62d): COMMIT; {"timestamp":"2023-08-15T07:17:17.178Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:17.179Z"}
info: User Already exists {"timestamp":"2023-08-15T07:17:17.181Z"}
info: User Created {"timestamp":"2023-08-15T07:17:17.181Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:17.185Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:17.202Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:17.210Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:17.217Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:17.225Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:17.227Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:17.228Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:17.229Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:17.231Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:17.234Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:17.245Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:17.251Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:17.253Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:17.259Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:17.262Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:17.264Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:17.274Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:17.277Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:17.279Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:17.290Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:17:22.954Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:23.106Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:17:23.108Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:23.109Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:17:23.110Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:17:23.135Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:17:23.136Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:17:23.195Z"}
debug: Executing (6560673c-e693-430e-a6fa-001655852181): START TRANSACTION; {"timestamp":"2023-08-15T07:17:23.196Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:23.197Z"}
debug: Executing (6560673c-e693-430e-a6fa-001655852181): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:17:23.205Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:23.210Z"}
debug: Executing (6560673c-e693-430e-a6fa-001655852181): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_d546c496732e44baab8c5ff01452e7b8$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:17:23.214 +00:00','2023-08-15 07:17:23.214 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_d546c496732e44baab8c5ff01452e7b8$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:17:23.221Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:23.223Z"}
debug: Executing (6560673c-e693-430e-a6fa-001655852181): COMMIT; {"timestamp":"2023-08-15T07:17:23.230Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:23.231Z"}
info: User Already exists {"timestamp":"2023-08-15T07:17:23.233Z"}
info: User Created {"timestamp":"2023-08-15T07:17:23.233Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:23.238Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:23.263Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:23.273Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:23.286Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:23.298Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:23.301Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:23.302Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:23.304Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:23.306Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:23.311Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:23.326Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:23.335Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:23.336Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:23.345Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:23.350Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:23.352Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:23.372Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:23.377Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:23.379Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:23.395Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:17:35.767Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:35.997Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:17:35.998Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:35.998Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:17:35.999Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:17:36.026Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:17:36.027Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:17:36.095Z"}
debug: Executing (b0779607-c952-4302-9e7d-81c9c5cb0f54): START TRANSACTION; {"timestamp":"2023-08-15T07:17:36.096Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:36.098Z"}
debug: Executing (b0779607-c952-4302-9e7d-81c9c5cb0f54): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:17:36.109Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:36.114Z"}
debug: Executing (b0779607-c952-4302-9e7d-81c9c5cb0f54): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_c3015de6db7a4d3ba3d913aebe243656$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:17:36.118 +00:00','2023-08-15 07:17:36.118 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_c3015de6db7a4d3ba3d913aebe243656$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:17:36.125Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:36.128Z"}
debug: Executing (b0779607-c952-4302-9e7d-81c9c5cb0f54): COMMIT; {"timestamp":"2023-08-15T07:17:36.135Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:36.136Z"}
info: User Already exists {"timestamp":"2023-08-15T07:17:36.137Z"}
info: User Created {"timestamp":"2023-08-15T07:17:36.138Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:36.143Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:36.170Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:36.182Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:36.194Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:36.207Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:36.210Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:36.213Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:36.214Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:36.217Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:36.221Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:36.237Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:36.247Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:36.249Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:36.258Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:36.263Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:36.266Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:36.281Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:36.285Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:36.287Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:36.303Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:17:38.335Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:38.487Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:17:38.488Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:17:38.489Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:17:38.490Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:17:38.516Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:17:38.517Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:17:38.587Z"}
debug: Executing (224aa66a-23a7-4f84-86b1-0665ab7f11ca): START TRANSACTION; {"timestamp":"2023-08-15T07:17:38.590Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:38.591Z"}
debug: Executing (224aa66a-23a7-4f84-86b1-0665ab7f11ca): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:17:38.603Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:38.609Z"}
debug: Executing (224aa66a-23a7-4f84-86b1-0665ab7f11ca): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_5d536df1ad964bf690e670251e6eb6a4$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:17:38.613 +00:00','2023-08-15 07:17:38.613 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_5d536df1ad964bf690e670251e6eb6a4$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:17:38.620Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:38.622Z"}
debug: Executing (224aa66a-23a7-4f84-86b1-0665ab7f11ca): COMMIT; {"timestamp":"2023-08-15T07:17:38.629Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:38.630Z"}
info: User Already exists {"timestamp":"2023-08-15T07:17:38.631Z"}
info: User Created {"timestamp":"2023-08-15T07:17:38.632Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:38.636Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:38.663Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:38.675Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:17:38.686Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:38.697Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:38.700Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:38.702Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:38.703Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:17:38.706Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:38.710Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:38.724Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:17:38.733Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:38.735Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:38.743Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:17:38.748Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:38.750Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:38.764Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:17:38.768Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:17:38.770Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:17:38.785Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:18:15.076Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:18:15.181Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:18:15.181Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:18:15.182Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:18:15.182Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:18:15.201Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:18:15.202Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:18:15.244Z"}
debug: Executing (eabdb28a-4c87-4e29-a38c-7b7d06b8633f): START TRANSACTION; {"timestamp":"2023-08-15T07:18:15.245Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:18:15.246Z"}
debug: Executing (eabdb28a-4c87-4e29-a38c-7b7d06b8633f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:18:15.251Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:18:15.255Z"}
debug: Executing (eabdb28a-4c87-4e29-a38c-7b7d06b8633f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_1d631becd4d24683ae527e3dd450217a$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:18:15.257 +00:00','2023-08-15 07:18:15.257 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_1d631becd4d24683ae527e3dd450217a$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:18:15.262Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:18:15.263Z"}
debug: Executing (eabdb28a-4c87-4e29-a38c-7b7d06b8633f): COMMIT; {"timestamp":"2023-08-15T07:18:15.267Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:18:15.268Z"}
info: User Already exists {"timestamp":"2023-08-15T07:18:15.269Z"}
info: User Created {"timestamp":"2023-08-15T07:18:15.270Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:18:15.273Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:18:15.290Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:18:15.298Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:18:15.304Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:18:15.312Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:18:15.314Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:18:15.315Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:18:15.316Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:18:15.318Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:18:15.320Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:18:15.330Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:18:15.335Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:18:15.337Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:18:15.343Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:18:15.346Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:18:15.348Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:18:15.358Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:18:15.361Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:18:15.362Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:18:15.372Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:19:29.000Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:19:29.103Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:19:29.103Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:19:29.104Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:19:29.112Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:19:29.129Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:19:29.129Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:19:29.170Z"}
debug: Executing (ec38b4f3-e984-41d2-ad4f-d8169aa22c5f): START TRANSACTION; {"timestamp":"2023-08-15T07:19:29.171Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:19:29.172Z"}
debug: Executing (ec38b4f3-e984-41d2-ad4f-d8169aa22c5f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:19:29.178Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:19:29.181Z"}
debug: Executing (ec38b4f3-e984-41d2-ad4f-d8169aa22c5f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_c8385fd6b4cd4ccb9a77b50a2c776e10$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:19:29.184 +00:00','2023-08-15 07:19:29.184 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_c8385fd6b4cd4ccb9a77b50a2c776e10$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:19:29.190Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:19:29.191Z"}
debug: Executing (ec38b4f3-e984-41d2-ad4f-d8169aa22c5f): COMMIT; {"timestamp":"2023-08-15T07:19:29.196Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:19:29.196Z"}
info: User Already exists {"timestamp":"2023-08-15T07:19:29.197Z"}
info: User Created {"timestamp":"2023-08-15T07:19:29.198Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:19:29.201Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:19:29.217Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:19:29.225Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:19:29.232Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:19:29.240Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:19:29.242Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:19:29.243Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:19:29.244Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:19:29.246Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:19:29.248Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:19:29.259Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:19:29.264Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:19:29.266Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:19:29.272Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:19:29.276Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:19:29.277Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:19:29.287Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:19:29.291Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:19:29.292Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:19:29.304Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:19:43.287Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:19:43.390Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:19:43.391Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:19:43.391Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:19:43.392Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:19:43.410Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:19:43.410Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:19:43.454Z"}
debug: Executing (26570dee-ab83-4623-9035-9f473cf4e976): START TRANSACTION; {"timestamp":"2023-08-15T07:19:43.455Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:19:43.457Z"}
debug: Executing (26570dee-ab83-4623-9035-9f473cf4e976): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:19:43.462Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:19:43.465Z"}
debug: Executing (26570dee-ab83-4623-9035-9f473cf4e976): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_471c8314284d421a932f640be456bca1$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:19:43.467 +00:00','2023-08-15 07:19:43.467 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_471c8314284d421a932f640be456bca1$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:19:43.472Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:19:43.474Z"}
debug: Executing (26570dee-ab83-4623-9035-9f473cf4e976): COMMIT; {"timestamp":"2023-08-15T07:19:43.478Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:19:43.478Z"}
info: User Already exists {"timestamp":"2023-08-15T07:19:43.480Z"}
info: User Created {"timestamp":"2023-08-15T07:19:43.480Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:19:43.483Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:19:43.499Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:19:43.506Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:19:43.515Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:19:43.525Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:19:43.527Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:19:43.528Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:19:43.531Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:19:43.532Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:19:43.536Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:19:43.546Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:19:43.552Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:19:43.553Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:19:43.559Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:19:43.562Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:19:43.564Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:19:43.573Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:19:43.576Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:19:43.578Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:19:43.588Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:21:02.485Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:21:02.609Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:21:02.609Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:21:02.610Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:21:02.610Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:21:02.629Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:21:02.630Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:21:02.674Z"}
debug: Executing (23ddb437-6e33-4d3f-af81-b6df82979394): START TRANSACTION; {"timestamp":"2023-08-15T07:21:02.675Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:21:02.678Z"}
debug: Executing (23ddb437-6e33-4d3f-af81-b6df82979394): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:21:02.684Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:21:02.687Z"}
debug: Executing (23ddb437-6e33-4d3f-af81-b6df82979394): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_eab0b20560b449b09da6d849532a4a0a$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:21:02.689 +00:00','2023-08-15 07:21:02.689 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_eab0b20560b449b09da6d849532a4a0a$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:21:02.693Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:21:02.694Z"}
debug: Executing (23ddb437-6e33-4d3f-af81-b6df82979394): COMMIT; {"timestamp":"2023-08-15T07:21:02.699Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:21:02.700Z"}
info: User Already exists {"timestamp":"2023-08-15T07:21:02.701Z"}
info: User Created {"timestamp":"2023-08-15T07:21:02.702Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:21:02.705Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:21:02.720Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:21:02.727Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:21:02.734Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:21:02.742Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:21:02.744Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:21:02.745Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:21:02.747Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:21:02.749Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:21:02.753Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:21:02.763Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:21:02.769Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:21:02.770Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:21:02.776Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:21:02.779Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:21:02.781Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:21:02.791Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:21:02.794Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:21:02.795Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:21:02.807Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:21:12.563Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:21:12.668Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:21:12.668Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:21:12.669Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:21:12.669Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:21:12.686Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:21:12.687Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:21:12.726Z"}
debug: Executing (3cf81677-7602-4677-9374-6bad0215a751): START TRANSACTION; {"timestamp":"2023-08-15T07:21:12.728Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:21:12.729Z"}
debug: Executing (3cf81677-7602-4677-9374-6bad0215a751): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:21:12.736Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:21:12.740Z"}
debug: Executing (3cf81677-7602-4677-9374-6bad0215a751): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_3fc7325e82c14844925068651c4e1252$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:21:12.742 +00:00','2023-08-15 07:21:12.742 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_3fc7325e82c14844925068651c4e1252$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:21:12.746Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:21:12.748Z"}
debug: Executing (3cf81677-7602-4677-9374-6bad0215a751): COMMIT; {"timestamp":"2023-08-15T07:21:12.754Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:21:12.754Z"}
info: User Already exists {"timestamp":"2023-08-15T07:21:12.756Z"}
info: User Created {"timestamp":"2023-08-15T07:21:12.756Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:21:12.759Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:21:12.775Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:21:12.783Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:21:12.789Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:21:12.797Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:21:12.798Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:21:12.800Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:21:12.802Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:21:12.803Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:21:12.806Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:21:12.817Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:21:12.823Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:21:12.824Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:21:12.829Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:21:12.833Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:21:12.835Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:21:12.845Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:21:12.847Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:21:12.850Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:21:12.861Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:22:11.811Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:22:11.936Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:22:11.937Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:22:11.937Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:22:11.938Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:22:11.958Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:22:11.959Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:22:12.004Z"}
debug: Executing (c1fc1967-ebff-4781-a629-2f1f35b649ca): START TRANSACTION; {"timestamp":"2023-08-15T07:22:12.005Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:22:12.006Z"}
debug: Executing (c1fc1967-ebff-4781-a629-2f1f35b649ca): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:22:12.012Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:22:12.016Z"}
debug: Executing (c1fc1967-ebff-4781-a629-2f1f35b649ca): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e5701e646000496d80bfcfd7f5c11550$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:22:12.019 +00:00','2023-08-15 07:22:12.019 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e5701e646000496d80bfcfd7f5c11550$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:22:12.023Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:22:12.024Z"}
debug: Executing (c1fc1967-ebff-4781-a629-2f1f35b649ca): COMMIT; {"timestamp":"2023-08-15T07:22:12.029Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:22:12.030Z"}
info: User Already exists {"timestamp":"2023-08-15T07:22:12.031Z"}
info: User Created {"timestamp":"2023-08-15T07:22:12.032Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:22:12.037Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:22:12.054Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:22:12.060Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:22:12.068Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:22:12.075Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:22:12.076Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:22:12.077Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:22:12.079Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:22:12.081Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:22:12.084Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:22:12.094Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:22:12.102Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:22:12.103Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:22:12.109Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:22:12.113Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:22:12.115Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:22:12.125Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:22:12.128Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:22:12.130Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:22:12.141Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:22:13.142Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:22:13.254Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:22:13.255Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:22:13.256Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:22:13.256Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:22:13.274Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:22:13.274Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:22:13.315Z"}
debug: Executing (2f185354-3bfa-48aa-bb0c-1f1a54a33823): START TRANSACTION; {"timestamp":"2023-08-15T07:22:13.316Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:22:13.317Z"}
debug: Executing (2f185354-3bfa-48aa-bb0c-1f1a54a33823): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:22:13.322Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:22:13.326Z"}
debug: Executing (2f185354-3bfa-48aa-bb0c-1f1a54a33823): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_0910698426f641398bd726a2679a6f59$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:22:13.328 +00:00','2023-08-15 07:22:13.328 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_0910698426f641398bd726a2679a6f59$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:22:13.333Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:22:13.334Z"}
debug: Executing (2f185354-3bfa-48aa-bb0c-1f1a54a33823): COMMIT; {"timestamp":"2023-08-15T07:22:13.339Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:22:13.339Z"}
info: User Already exists {"timestamp":"2023-08-15T07:22:13.341Z"}
info: User Created {"timestamp":"2023-08-15T07:22:13.341Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:22:13.344Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:22:13.361Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:22:13.370Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:22:13.376Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:22:13.386Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:22:13.388Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:22:13.389Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:22:13.391Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:22:13.394Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:22:13.402Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:22:13.422Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:22:13.428Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:22:13.430Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:22:13.437Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:22:13.441Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:22:13.442Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:22:13.454Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:22:13.457Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:22:13.458Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:22:13.472Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:23:05.997Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:23:06.116Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:23:06.117Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:23:06.117Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:23:06.118Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:23:06.137Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:23:06.137Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:23:06.178Z"}
debug: Executing (61cdb213-8c7d-4c08-a715-a9613e4463c2): START TRANSACTION; {"timestamp":"2023-08-15T07:23:06.179Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:23:06.181Z"}
debug: Executing (61cdb213-8c7d-4c08-a715-a9613e4463c2): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:23:06.187Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:23:06.189Z"}
debug: Executing (61cdb213-8c7d-4c08-a715-a9613e4463c2): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_ed694f0492ca42e9b1e7f6e4add012d3$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:23:06.193 +00:00','2023-08-15 07:23:06.193 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_ed694f0492ca42e9b1e7f6e4add012d3$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:23:06.199Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:23:06.200Z"}
debug: Executing (61cdb213-8c7d-4c08-a715-a9613e4463c2): COMMIT; {"timestamp":"2023-08-15T07:23:06.205Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:23:06.206Z"}
info: User Already exists {"timestamp":"2023-08-15T07:23:06.207Z"}
info: User Created {"timestamp":"2023-08-15T07:23:06.207Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:23:06.211Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:23:06.231Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:23:06.239Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:23:06.247Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:23:06.254Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:23:06.255Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:23:06.256Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:23:06.257Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:23:06.258Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:23:06.261Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:23:06.271Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:23:06.277Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:23:06.279Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:23:06.285Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:23:06.288Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:23:06.289Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:23:06.300Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:23:06.303Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:23:06.304Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:23:06.315Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:23:40.123Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:23:40.239Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:23:40.239Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:23:40.240Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:23:40.241Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:23:40.261Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:23:40.262Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:23:40.303Z"}
debug: Executing (59f76c7a-bd91-4552-8740-f125027efdd3): START TRANSACTION; {"timestamp":"2023-08-15T07:23:40.304Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:23:40.305Z"}
debug: Executing (59f76c7a-bd91-4552-8740-f125027efdd3): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:23:40.311Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:23:40.314Z"}
debug: Executing (59f76c7a-bd91-4552-8740-f125027efdd3): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_2674d0ff455043ce8b54d4b928e5d0d9$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:23:40.316 +00:00','2023-08-15 07:23:40.316 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_2674d0ff455043ce8b54d4b928e5d0d9$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:23:40.320Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:23:40.321Z"}
debug: Executing (59f76c7a-bd91-4552-8740-f125027efdd3): COMMIT; {"timestamp":"2023-08-15T07:23:40.327Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:23:40.327Z"}
info: User Already exists {"timestamp":"2023-08-15T07:23:40.329Z"}
info: User Created {"timestamp":"2023-08-15T07:23:40.329Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:23:40.333Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:23:40.350Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:23:40.358Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:23:40.365Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:23:40.373Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:23:40.376Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:23:40.378Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:23:40.379Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:23:40.381Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:23:40.384Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:23:40.394Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:23:40.400Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:23:40.401Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:23:40.407Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:23:40.411Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:23:40.412Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:23:40.422Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:23:40.425Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:23:40.426Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:23:40.437Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:24:15.213Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:24:15.314Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:24:15.314Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:24:15.315Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:24:15.316Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:24:15.334Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:24:15.335Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:24:15.374Z"}
debug: Executing (3bea8e7e-18f7-49cc-a67a-c2f59a0e0cce): START TRANSACTION; {"timestamp":"2023-08-15T07:24:15.375Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:15.376Z"}
debug: Executing (3bea8e7e-18f7-49cc-a67a-c2f59a0e0cce): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:24:15.382Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:15.386Z"}
debug: Executing (3bea8e7e-18f7-49cc-a67a-c2f59a0e0cce): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_8388642f48e04c64aae667921912e551$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:24:15.387 +00:00','2023-08-15 07:24:15.387 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_8388642f48e04c64aae667921912e551$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:24:15.392Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:15.394Z"}
debug: Executing (3bea8e7e-18f7-49cc-a67a-c2f59a0e0cce): COMMIT; {"timestamp":"2023-08-15T07:24:15.398Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:15.399Z"}
info: User Already exists {"timestamp":"2023-08-15T07:24:15.400Z"}
info: User Created {"timestamp":"2023-08-15T07:24:15.401Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:15.404Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:15.419Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:15.427Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:15.433Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:15.440Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:15.442Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:15.444Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:15.445Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:15.447Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:15.449Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:15.459Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:15.465Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:15.466Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:15.472Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:15.476Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:15.477Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:15.487Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:15.490Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:15.492Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:15.502Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:24:26.247Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:24:26.347Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:24:26.348Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:24:26.348Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:24:26.349Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:24:26.366Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:24:26.367Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:24:26.405Z"}
debug: Executing (c591fae3-a0b5-4961-929d-c68337277d1c): START TRANSACTION; {"timestamp":"2023-08-15T07:24:26.407Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:26.408Z"}
debug: Executing (c591fae3-a0b5-4961-929d-c68337277d1c): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:24:26.413Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:26.417Z"}
debug: Executing (c591fae3-a0b5-4961-929d-c68337277d1c): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_f720d68ef1974329a5ecf34a29ecc417$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:24:26.418 +00:00','2023-08-15 07:24:26.418 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_f720d68ef1974329a5ecf34a29ecc417$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:24:26.423Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:26.424Z"}
debug: Executing (c591fae3-a0b5-4961-929d-c68337277d1c): COMMIT; {"timestamp":"2023-08-15T07:24:26.429Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:26.429Z"}
info: User Already exists {"timestamp":"2023-08-15T07:24:26.431Z"}
info: User Created {"timestamp":"2023-08-15T07:24:26.431Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:26.434Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:26.455Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:26.464Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:26.470Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:26.478Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:26.479Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:26.481Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:26.482Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:26.483Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:26.486Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:26.496Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:26.502Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:26.504Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:26.510Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:26.513Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:26.515Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:26.525Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:26.527Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:26.529Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:26.539Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:24:53.020Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:24:53.125Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:24:53.126Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:24:53.127Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:24:53.128Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:24:53.145Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:24:53.146Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:24:53.187Z"}
debug: Executing (8fb33520-8d5f-41c0-9778-1630f0927241): START TRANSACTION; {"timestamp":"2023-08-15T07:24:53.190Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:53.191Z"}
debug: Executing (8fb33520-8d5f-41c0-9778-1630f0927241): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:24:53.196Z"}
debug: Executing (8fb33520-8d5f-41c0-9778-1630f0927241): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_b0b0696712d0453a8e3776918b6daa78$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:24:53.202 +00:00','2023-08-15 07:24:53.202 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_b0b0696712d0453a8e3776918b6daa78$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:24:53.207Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:53.208Z"}
debug: Executing (8fb33520-8d5f-41c0-9778-1630f0927241): COMMIT; {"timestamp":"2023-08-15T07:24:53.213Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:53.214Z"}
info: User Already exists {"timestamp":"2023-08-15T07:24:53.215Z"}
info: User Created {"timestamp":"2023-08-15T07:24:53.215Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:53.218Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:53.223Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:53.240Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:53.246Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:24:53.254Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:53.262Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:53.263Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:53.265Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:53.267Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:24:53.269Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:53.273Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:53.283Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:24:53.291Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:53.293Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:53.301Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:24:53.304Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:53.306Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:53.316Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:24:53.318Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:24:53.320Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:24:53.330Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:25:18.958Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:25:19.057Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:25:19.058Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:25:19.058Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:25:19.059Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:25:19.077Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:25:19.077Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:25:19.116Z"}
debug: Executing (4b0597a5-75c2-49d1-9f23-42f5947b7267): START TRANSACTION; {"timestamp":"2023-08-15T07:25:19.117Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:19.118Z"}
debug: Executing (4b0597a5-75c2-49d1-9f23-42f5947b7267): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:25:19.126Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:19.130Z"}
debug: Executing (4b0597a5-75c2-49d1-9f23-42f5947b7267): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_04b37eec3d134438b4c1475cad3446e8$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:25:19.131 +00:00','2023-08-15 07:25:19.131 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_04b37eec3d134438b4c1475cad3446e8$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:25:19.135Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:19.137Z"}
debug: Executing (4b0597a5-75c2-49d1-9f23-42f5947b7267): COMMIT; {"timestamp":"2023-08-15T07:25:19.142Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:19.142Z"}
info: User Already exists {"timestamp":"2023-08-15T07:25:19.144Z"}
info: User Created {"timestamp":"2023-08-15T07:25:19.144Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:19.147Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:19.163Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:19.170Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:19.177Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:19.184Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:19.185Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:19.186Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:19.187Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:19.189Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:19.192Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:19.202Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:19.208Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:19.209Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:19.215Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:19.218Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:19.220Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:19.229Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:19.231Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:19.233Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:19.243Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:25:25.370Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:25:25.511Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:25:25.512Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:25:25.513Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:25:25.514Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:25:25.537Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:25:25.538Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:25:25.597Z"}
debug: Executing (4312651f-7b67-4429-ac19-89feffbe9b14): START TRANSACTION; {"timestamp":"2023-08-15T07:25:25.598Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:25.600Z"}
debug: Executing (4312651f-7b67-4429-ac19-89feffbe9b14): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:25:25.610Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:25.613Z"}
debug: Executing (4312651f-7b67-4429-ac19-89feffbe9b14): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_b5236d68dbae4ed7ba71c9b6490c9e1b$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:25:25.618 +00:00','2023-08-15 07:25:25.618 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_b5236d68dbae4ed7ba71c9b6490c9e1b$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:25:25.624Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:25.626Z"}
debug: Executing (4312651f-7b67-4429-ac19-89feffbe9b14): COMMIT; {"timestamp":"2023-08-15T07:25:25.632Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:25.633Z"}
info: User Already exists {"timestamp":"2023-08-15T07:25:25.635Z"}
info: User Created {"timestamp":"2023-08-15T07:25:25.635Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:25.641Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:25.664Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:25.675Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:25.684Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:25.696Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:25.698Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:25.699Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:25.701Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:25.703Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:25.708Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:25.721Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:25.730Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:25.732Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:25.740Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:25.744Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:25.746Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:25.760Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:25.764Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:25.766Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:25.781Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:25:30.884Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:25:31.038Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:25:31.039Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:25:31.040Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:25:31.041Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:25:31.067Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:25:31.067Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:25:31.127Z"}
debug: Executing (2bfdfed5-7d07-402c-8fa0-1b0f78cef8c5): START TRANSACTION; {"timestamp":"2023-08-15T07:25:31.128Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:31.130Z"}
debug: Executing (2bfdfed5-7d07-402c-8fa0-1b0f78cef8c5): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:25:31.138Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:31.143Z"}
debug: Executing (2bfdfed5-7d07-402c-8fa0-1b0f78cef8c5): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_013e5512193a4e689ce216b78e887d34$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:25:31.146 +00:00','2023-08-15 07:25:31.146 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_013e5512193a4e689ce216b78e887d34$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:25:31.153Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:31.155Z"}
debug: Executing (2bfdfed5-7d07-402c-8fa0-1b0f78cef8c5): COMMIT; {"timestamp":"2023-08-15T07:25:31.162Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:31.163Z"}
info: User Already exists {"timestamp":"2023-08-15T07:25:31.165Z"}
info: User Created {"timestamp":"2023-08-15T07:25:31.166Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:31.171Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:31.196Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:31.207Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:25:31.218Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:31.229Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:31.231Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:31.233Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:31.234Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:25:31.237Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:31.241Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:31.255Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:25:31.263Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:31.265Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:31.273Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:25:31.278Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:31.280Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:31.295Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:25:31.299Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:25:31.301Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:25:31.316Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:26:02.961Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:26:03.067Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:26:03.068Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:26:03.069Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:26:03.069Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:26:03.087Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:26:03.088Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:26:03.133Z"}
debug: Executing (bb35fefe-b7a7-42cf-84e4-2579b603fa12): START TRANSACTION; {"timestamp":"2023-08-15T07:26:03.136Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:03.137Z"}
debug: Executing (bb35fefe-b7a7-42cf-84e4-2579b603fa12): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:26:03.146Z"}
debug: Executing (bb35fefe-b7a7-42cf-84e4-2579b603fa12): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_5ab549c38a2d4d28940bb185e0a292e3$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:26:03.152 +00:00','2023-08-15 07:26:03.152 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_5ab549c38a2d4d28940bb185e0a292e3$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:26:03.157Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:03.158Z"}
debug: Executing (bb35fefe-b7a7-42cf-84e4-2579b603fa12): COMMIT; {"timestamp":"2023-08-15T07:26:03.164Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:03.165Z"}
info: User Already exists {"timestamp":"2023-08-15T07:26:03.166Z"}
info: User Created {"timestamp":"2023-08-15T07:26:03.166Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:03.170Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:03.175Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:03.194Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:03.203Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:03.211Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:03.222Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:03.224Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:03.225Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:03.227Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:03.229Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:03.232Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:03.244Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:03.251Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:03.253Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:03.259Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:03.263Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:03.265Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:03.277Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:03.281Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:03.283Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:03.295Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:26:10.333Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:26:10.453Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:26:10.454Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:26:10.454Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:26:10.455Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:26:10.481Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:26:10.482Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:26:10.536Z"}
debug: Executing (bef78ce3-30a9-45c8-82a6-abcde2d05a1f): START TRANSACTION; {"timestamp":"2023-08-15T07:26:10.538Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:10.539Z"}
debug: Executing (bef78ce3-30a9-45c8-82a6-abcde2d05a1f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:26:10.547Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:10.548Z"}
debug: Executing (bef78ce3-30a9-45c8-82a6-abcde2d05a1f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_d997752dedc34ecc8413d16f526617a2$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:26:10.553 +00:00','2023-08-15 07:26:10.553 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_d997752dedc34ecc8413d16f526617a2$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:26:10.558Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:10.560Z"}
debug: Executing (bef78ce3-30a9-45c8-82a6-abcde2d05a1f): COMMIT; {"timestamp":"2023-08-15T07:26:10.564Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:10.565Z"}
info: User Already exists {"timestamp":"2023-08-15T07:26:10.566Z"}
info: User Created {"timestamp":"2023-08-15T07:26:10.567Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:10.571Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:10.588Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:10.595Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:10.602Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:10.610Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:10.612Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:10.614Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:10.615Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:10.616Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:10.620Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:10.630Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:10.637Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:10.639Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:10.646Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:10.649Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:10.651Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:10.661Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:10.664Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:10.665Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:10.675Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:26:25.764Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:26:25.895Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:26:25.896Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:26:25.897Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:26:25.898Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:26:25.920Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:26:25.921Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:26:25.979Z"}
debug: Executing (8908fc67-5928-4fc0-9f46-2a52ab796aa0): START TRANSACTION; {"timestamp":"2023-08-15T07:26:25.980Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:25.981Z"}
debug: Executing (8908fc67-5928-4fc0-9f46-2a52ab796aa0): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:26:25.989Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:25.993Z"}
debug: Executing (8908fc67-5928-4fc0-9f46-2a52ab796aa0): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_2ffc4bfe08f246c6bd6addc99fa8a41c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:26:25.996 +00:00','2023-08-15 07:26:25.996 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_2ffc4bfe08f246c6bd6addc99fa8a41c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:26:26.002Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:26.004Z"}
debug: Executing (8908fc67-5928-4fc0-9f46-2a52ab796aa0): COMMIT; {"timestamp":"2023-08-15T07:26:26.009Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:26.010Z"}
info: User Already exists {"timestamp":"2023-08-15T07:26:26.012Z"}
info: User Created {"timestamp":"2023-08-15T07:26:26.012Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:26.017Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:26.041Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:26.052Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:26:26.061Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:26.072Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:26.074Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:26.075Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:26.077Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:26:26.079Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:26.083Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:26.095Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:26:26.107Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:26.110Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:26.119Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:26:26.124Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:26.126Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:26.140Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:26:26.144Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:26:26.146Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:26:26.162Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = 'P@ssword123**')) LIMIT 1; {"timestamp":"2023-08-15T07:26:28.062Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:27:03.658Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:27:03.764Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:27:03.765Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:27:03.766Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:27:03.766Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:27:03.785Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:27:03.786Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:27:03.827Z"}
debug: Executing (0f315255-3839-4a6e-a960-ae2a3ad5fa0a): START TRANSACTION; {"timestamp":"2023-08-15T07:27:03.828Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:27:03.828Z"}
debug: Executing (0f315255-3839-4a6e-a960-ae2a3ad5fa0a): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:27:03.835Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:27:03.838Z"}
debug: Executing (0f315255-3839-4a6e-a960-ae2a3ad5fa0a): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_f01fa3aeae4443549a580569fcd7fcac$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:27:03.841 +00:00','2023-08-15 07:27:03.841 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_f01fa3aeae4443549a580569fcd7fcac$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:27:03.846Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:27:03.847Z"}
debug: Executing (0f315255-3839-4a6e-a960-ae2a3ad5fa0a): COMMIT; {"timestamp":"2023-08-15T07:27:03.853Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:27:03.853Z"}
info: User Already exists {"timestamp":"2023-08-15T07:27:03.854Z"}
info: User Created {"timestamp":"2023-08-15T07:27:03.855Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:27:03.858Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:27:03.876Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:27:03.883Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:27:03.892Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:27:03.903Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:27:03.904Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:27:03.905Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:27:03.906Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:27:03.908Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:27:03.910Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:27:03.921Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:27:03.926Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:27:03.928Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:27:03.934Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:27:03.937Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:27:03.939Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:27:03.949Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:27:03.952Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:27:03.953Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:27:03.964Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = 'P@ssword123**')) LIMIT 1; {"timestamp":"2023-08-15T07:27:04.660Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:28:55.887Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:28:56.020Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:28:56.022Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:28:56.022Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:28:56.023Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:28:56.044Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:28:56.045Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:28:56.090Z"}
debug: Executing (d4f38bf1-7d31-49d8-aa97-a9116131167a): START TRANSACTION; {"timestamp":"2023-08-15T07:28:56.092Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:28:56.093Z"}
debug: Executing (d4f38bf1-7d31-49d8-aa97-a9116131167a): COMMIT; {"timestamp":"2023-08-15T07:28:56.098Z"}
error: Error authenticating Postgress Db The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined {"code":"ERR_INVALID_ARG_TYPE","stack":"TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined\n    at new NodeError (node:internal/errors:399:5)\n    at Hash.update (node:internal/crypto/hash:109:11)\n    at users.beforeFind (D:\\esa\\backend\\app\\models\\users.js:41:61)\n    at users.runHooks (D:\\esa\\backend\\node_modules\\sequelize\\lib\\hooks.js:96:18)\n    at users.findAll (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1113:18)\n    at users.findOne (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1240:23)\n    at users.findOrCreate (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1411:32)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async connect (D:\\esa\\backend\\index.js:77:33)","timestamp":"2023-08-15T07:28:56.100Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:28:56.103Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:28:56.109Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:28:56.114Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:28:56.119Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:28:56.137Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:28:56.144Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:28:56.151Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:28:56.158Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:28:56.160Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:28:56.162Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:28:56.163Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:28:56.165Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:28:56.168Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:28:56.177Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:28:56.184Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:28:56.186Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:28:56.191Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:28:56.195Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:28:56.196Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:28:56.207Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:28:56.209Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:28:56.211Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:28:56.221Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:29:19.099Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:29:19.205Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:29:19.206Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:29:19.207Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:29:19.207Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:29:19.225Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:29:19.226Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:29:19.266Z"}
debug: Executing (20879f0e-a997-4295-8611-07247cb52141): START TRANSACTION; {"timestamp":"2023-08-15T07:29:19.266Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:19.267Z"}
debug: Executing (20879f0e-a997-4295-8611-07247cb52141): COMMIT; {"timestamp":"2023-08-15T07:29:19.271Z"}
error: Error authenticating Postgress Db The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined {"code":"ERR_INVALID_ARG_TYPE","stack":"TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined\n    at new NodeError (node:internal/errors:399:5)\n    at Hash.update (node:internal/crypto/hash:109:11)\n    at users.beforeFind (D:\\esa\\backend\\app\\models\\users.js:41:61)\n    at users.runHooks (D:\\esa\\backend\\node_modules\\sequelize\\lib\\hooks.js:96:18)\n    at users.findAll (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1113:18)\n    at users.findOne (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1240:23)\n    at users.findOrCreate (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1411:32)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async connect (D:\\esa\\backend\\index.js:77:33)","timestamp":"2023-08-15T07:29:19.272Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:19.276Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:19.282Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:19.286Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:19.291Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:19.307Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:19.314Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:19.321Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:19.328Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:19.329Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:19.331Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:19.332Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:19.333Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:19.336Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:19.346Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:19.351Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:19.353Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:19.358Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:19.361Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:19.363Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:19.372Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:19.375Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:19.377Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:19.387Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:29:36.662Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:29:36.771Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:29:36.772Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:29:36.772Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:29:36.773Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:29:36.791Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:29:36.792Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:29:36.836Z"}
debug: Executing (372b336b-f556-4776-b8a8-ed69a16b5492): START TRANSACTION; {"timestamp":"2023-08-15T07:29:36.836Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:36.837Z"}
debug: Executing (372b336b-f556-4776-b8a8-ed69a16b5492): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:29:36.843Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:36.848Z"}
debug: Executing (372b336b-f556-4776-b8a8-ed69a16b5492): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_28aa976dae2f4ee69f1ef8e699c8cff7$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:29:36.849 +00:00','2023-08-15 07:29:36.849 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_28aa976dae2f4ee69f1ef8e699c8cff7$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:29:36.853Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:36.854Z"}
debug: Executing (372b336b-f556-4776-b8a8-ed69a16b5492): COMMIT; {"timestamp":"2023-08-15T07:29:36.859Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:36.860Z"}
info: User Already exists {"timestamp":"2023-08-15T07:29:36.861Z"}
info: User Created {"timestamp":"2023-08-15T07:29:36.862Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:36.865Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:36.882Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = 'P@ssword123**')) LIMIT 1; {"timestamp":"2023-08-15T07:29:36.889Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:36.890Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:36.899Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:36.906Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:36.908Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:36.909Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:36.910Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:36.912Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:36.915Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:36.925Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:36.931Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:36.933Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:36.938Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:36.941Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:36.944Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:36.954Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:36.956Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:36.958Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:36.968Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:29:52.750Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:29:52.924Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:29:52.925Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:29:52.926Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:29:52.927Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:29:52.956Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:29:52.957Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:29:53.045Z"}
debug: Executing (2747ec10-b1f1-4c9b-9367-c22f6ae84f50): START TRANSACTION; {"timestamp":"2023-08-15T07:29:53.049Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:53.051Z"}
debug: Executing (2747ec10-b1f1-4c9b-9367-c22f6ae84f50): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:29:53.062Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:53.070Z"}
debug: Executing (2747ec10-b1f1-4c9b-9367-c22f6ae84f50): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_38e8fcf946ee4f4983d3062807994b84$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:29:53.074 +00:00','2023-08-15 07:29:53.074 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_38e8fcf946ee4f4983d3062807994b84$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:29:53.082Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:53.084Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:53.093Z"}
debug: Executing (2747ec10-b1f1-4c9b-9367-c22f6ae84f50): COMMIT; {"timestamp":"2023-08-15T07:29:53.095Z"}
info: User Already exists {"timestamp":"2023-08-15T07:29:53.098Z"}
info: User Created {"timestamp":"2023-08-15T07:29:53.099Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:53.106Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:53.136Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:53.150Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:29:53.166Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:53.178Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:53.180Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:53.182Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:53.184Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:29:53.186Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:53.191Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:53.208Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:29:53.218Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:53.220Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:53.229Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:29:53.234Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:53.237Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:53.251Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:29:53.255Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:29:53.258Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:29:53.273Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = 'P@ssword123**')) LIMIT 1; {"timestamp":"2023-08-15T07:29:55.261Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:30:06.900Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:30:07.005Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:30:07.006Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:30:07.007Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:30:07.008Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:30:07.026Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:30:07.027Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:30:07.073Z"}
debug: Executing (d2f9aa7f-468a-45ee-9f0c-6f157d782c89): START TRANSACTION; {"timestamp":"2023-08-15T07:30:07.074Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:30:07.076Z"}
debug: Executing (d2f9aa7f-468a-45ee-9f0c-6f157d782c89): COMMIT; {"timestamp":"2023-08-15T07:30:07.080Z"}
error: Error authenticating Postgress Db The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined {"code":"ERR_INVALID_ARG_TYPE","stack":"TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined\n    at new NodeError (node:internal/errors:399:5)\n    at Hash.update (node:internal/crypto/hash:109:11)\n    at users.beforeFind (D:\\esa\\backend\\app\\models\\users.js:41:61)\n    at users.runHooks (D:\\esa\\backend\\node_modules\\sequelize\\lib\\hooks.js:96:18)\n    at users.findAll (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1113:18)\n    at users.findOne (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1240:23)\n    at users.findOrCreate (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1411:32)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async connect (D:\\esa\\backend\\index.js:77:33)","timestamp":"2023-08-15T07:30:07.083Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:30:07.087Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:30:07.094Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:30:07.098Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:30:07.104Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:30:07.123Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:30:07.131Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:30:07.139Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:30:07.149Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:30:07.150Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:30:07.151Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:30:07.153Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:30:07.154Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:30:07.158Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:30:07.169Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:30:07.176Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:30:07.178Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:30:07.185Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:30:07.188Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:30:07.190Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:30:07.201Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:30:07.204Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:30:07.206Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:30:07.218Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:30:29.760Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:30:29.897Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:30:29.898Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:30:29.898Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:30:29.899Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:30:29.922Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:30:29.923Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:30:29.978Z"}
debug: Executing (246d1df1-f8d2-4d2a-8a37-5b29f9d6e325): START TRANSACTION; {"timestamp":"2023-08-15T07:30:29.980Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:30:29.981Z"}
debug: Executing (246d1df1-f8d2-4d2a-8a37-5b29f9d6e325): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:30:29.988Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:30:29.993Z"}
debug: Executing (246d1df1-f8d2-4d2a-8a37-5b29f9d6e325): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e4433d68ce514beeb55787294fe5f2c6$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:30:29.996 +00:00','2023-08-15 07:30:29.996 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e4433d68ce514beeb55787294fe5f2c6$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:30:30.002Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:30:30.004Z"}
debug: Executing (246d1df1-f8d2-4d2a-8a37-5b29f9d6e325): COMMIT; {"timestamp":"2023-08-15T07:30:30.011Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:30:30.012Z"}
info: User Already exists {"timestamp":"2023-08-15T07:30:30.013Z"}
info: User Created {"timestamp":"2023-08-15T07:30:30.014Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:30:30.019Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:30:30.044Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:30:30.054Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:30:30.065Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:30:30.076Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:30:30.078Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:30:30.079Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:30:30.080Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:30:30.083Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:30:30.086Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:30:30.100Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:30:30.108Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:30:30.110Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:30:30.118Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:30:30.123Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:30:30.125Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:30:30.139Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:30:30.143Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:30:30.145Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:30:30.159Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:31:53.499Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:31:53.606Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:31:53.607Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:31:53.608Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:31:53.608Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:31:53.627Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:31:53.628Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:31:53.670Z"}
debug: Executing (d44f5d52-cc6f-4a78-b7c4-c8c18b77c24c): START TRANSACTION; {"timestamp":"2023-08-15T07:31:53.672Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:31:53.674Z"}
debug: Executing (d44f5d52-cc6f-4a78-b7c4-c8c18b77c24c): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:31:53.680Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:31:53.683Z"}
debug: Executing (d44f5d52-cc6f-4a78-b7c4-c8c18b77c24c): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_ea444d3cbd80429e9e9033c340d92e7b$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:31:53.688 +00:00','2023-08-15 07:31:53.688 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_ea444d3cbd80429e9e9033c340d92e7b$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:31:53.693Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:31:53.694Z"}
debug: Executing (d44f5d52-cc6f-4a78-b7c4-c8c18b77c24c): COMMIT; {"timestamp":"2023-08-15T07:31:53.699Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:31:53.699Z"}
info: User Already exists {"timestamp":"2023-08-15T07:31:53.700Z"}
info: User Created {"timestamp":"2023-08-15T07:31:53.701Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:31:53.705Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:31:53.721Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:31:53.728Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:31:53.734Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:31:53.741Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:31:53.742Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:31:53.744Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:31:53.745Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:31:53.746Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:31:53.749Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:31:53.759Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:31:53.764Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:31:53.766Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:31:53.772Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:31:53.775Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:31:53.776Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:31:53.786Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:31:53.789Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:31:53.790Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:31:53.800Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:32:16.603Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:32:16.709Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:32:16.709Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:32:16.710Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:32:16.711Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:32:16.728Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:32:16.729Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:32:16.768Z"}
debug: Executing (9c9121a2-e0f4-4f6d-b7a3-c56d559d8819): START TRANSACTION; {"timestamp":"2023-08-15T07:32:16.769Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:16.770Z"}
debug: Executing (9c9121a2-e0f4-4f6d-b7a3-c56d559d8819): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:32:16.776Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:16.779Z"}
debug: Executing (9c9121a2-e0f4-4f6d-b7a3-c56d559d8819): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_20449e70e5594953a4275ac04c7bb71c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:32:16.781 +00:00','2023-08-15 07:32:16.781 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_20449e70e5594953a4275ac04c7bb71c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:32:16.785Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:16.786Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:16.790Z"}
debug: Executing (9c9121a2-e0f4-4f6d-b7a3-c56d559d8819): COMMIT; {"timestamp":"2023-08-15T07:32:16.792Z"}
info: User Already exists {"timestamp":"2023-08-15T07:32:16.794Z"}
info: User Created {"timestamp":"2023-08-15T07:32:16.795Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:16.798Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:16.816Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:16.823Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:16.829Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:16.836Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:16.838Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:16.839Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:16.840Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:16.841Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:16.844Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:16.854Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:16.859Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:16.860Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:16.867Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:16.871Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:16.872Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:16.882Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:16.884Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:16.886Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:16.895Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:32:18.046Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:32:18.147Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:32:18.148Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:32:18.148Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:32:18.149Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:32:18.166Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:32:18.167Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:32:18.222Z"}
debug: Executing (d718b853-9548-4e33-a600-39e0e46eed20): START TRANSACTION; {"timestamp":"2023-08-15T07:32:18.224Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:18.225Z"}
debug: Executing (d718b853-9548-4e33-a600-39e0e46eed20): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:32:18.230Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:18.233Z"}
debug: Executing (d718b853-9548-4e33-a600-39e0e46eed20): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_89abbe72f962439a914759c6d0a1ec0f$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:32:18.236 +00:00','2023-08-15 07:32:18.236 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_89abbe72f962439a914759c6d0a1ec0f$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:32:18.241Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:18.242Z"}
debug: Executing (d718b853-9548-4e33-a600-39e0e46eed20): COMMIT; {"timestamp":"2023-08-15T07:32:18.246Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:18.247Z"}
info: User Already exists {"timestamp":"2023-08-15T07:32:18.248Z"}
info: User Created {"timestamp":"2023-08-15T07:32:18.249Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:18.253Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:18.267Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:18.274Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:18.280Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:18.287Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:18.288Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:18.289Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:18.290Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:18.292Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:18.294Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:18.305Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:18.311Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:18.312Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:18.317Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:18.320Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:18.322Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:18.331Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:18.334Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:18.336Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:18.346Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:32:22.338Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:32:58.405Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:32:58.540Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:32:58.541Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:32:58.541Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:32:58.542Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:32:58.562Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:32:58.563Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:32:58.614Z"}
debug: Executing (78d1f9ba-6f9f-4028-9993-38e00789f31d): START TRANSACTION; {"timestamp":"2023-08-15T07:32:58.615Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:58.617Z"}
debug: Executing (78d1f9ba-6f9f-4028-9993-38e00789f31d): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:32:58.627Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:58.630Z"}
debug: Executing (78d1f9ba-6f9f-4028-9993-38e00789f31d): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e14c5beedbf34406854e8a26c2ad5969$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:32:58.634 +00:00','2023-08-15 07:32:58.634 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e14c5beedbf34406854e8a26c2ad5969$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:32:58.638Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:58.640Z"}
debug: Executing (78d1f9ba-6f9f-4028-9993-38e00789f31d): COMMIT; {"timestamp":"2023-08-15T07:32:58.645Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:58.646Z"}
info: User Already exists {"timestamp":"2023-08-15T07:32:58.647Z"}
info: User Created {"timestamp":"2023-08-15T07:32:58.648Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:58.655Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:58.673Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:58.681Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:32:58.689Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:58.698Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:58.700Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:58.702Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:58.703Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:32:58.705Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:58.708Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:58.719Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:32:58.724Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:58.725Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:58.732Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:32:58.736Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:58.737Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:58.747Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:32:58.750Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:32:58.752Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:32:58.762Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:33:03.618Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:33:20.519Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:33:20.627Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:33:20.628Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:33:20.629Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:33:20.629Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:33:20.647Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:33:20.648Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:33:20.699Z"}
debug: Executing (d9610f66-6cff-4041-b40b-25f6771c4c80): START TRANSACTION; {"timestamp":"2023-08-15T07:33:20.700Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:20.701Z"}
debug: Executing (d9610f66-6cff-4041-b40b-25f6771c4c80): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:33:20.706Z"}
debug: Executing (d9610f66-6cff-4041-b40b-25f6771c4c80): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_16496f65d54e4a04941410b56750100c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:33:20.711 +00:00','2023-08-15 07:33:20.711 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_16496f65d54e4a04941410b56750100c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:33:20.716Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:20.717Z"}
debug: Executing (d9610f66-6cff-4041-b40b-25f6771c4c80): COMMIT; {"timestamp":"2023-08-15T07:33:20.723Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:20.724Z"}
info: User Already exists {"timestamp":"2023-08-15T07:33:20.725Z"}
info: User Created {"timestamp":"2023-08-15T07:33:20.725Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:20.728Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:20.733Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:20.750Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:20.758Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:20.765Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:20.772Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:20.773Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:20.774Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:20.775Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:20.777Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:20.779Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:20.789Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:20.795Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:20.796Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:20.804Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:20.807Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:20.809Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:20.820Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:20.823Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:20.825Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:20.836Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:33:40.585Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:33:40.687Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:33:40.687Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:33:40.688Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:33:40.689Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:33:40.706Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:33:40.707Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:33:40.746Z"}
debug: Executing (3113ae77-e438-444d-a8bf-91a86c00cc53): START TRANSACTION; {"timestamp":"2023-08-15T07:33:40.747Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:40.749Z"}
debug: Executing (3113ae77-e438-444d-a8bf-91a86c00cc53): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:33:40.755Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:40.758Z"}
debug: Executing (3113ae77-e438-444d-a8bf-91a86c00cc53): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_58cbdf77e0f847ef985b78b909cf9e9c$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:33:40.761 +00:00','2023-08-15 07:33:40.761 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_58cbdf77e0f847ef985b78b909cf9e9c$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:33:40.766Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:40.767Z"}
debug: Executing (3113ae77-e438-444d-a8bf-91a86c00cc53): COMMIT; {"timestamp":"2023-08-15T07:33:40.772Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:40.772Z"}
info: User Already exists {"timestamp":"2023-08-15T07:33:40.774Z"}
info: User Created {"timestamp":"2023-08-15T07:33:40.774Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:40.778Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:40.793Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:40.801Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:40.807Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:40.813Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:40.815Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:40.817Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:40.818Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:40.819Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:40.822Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:40.832Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:40.837Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:40.839Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:40.844Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:40.847Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:40.849Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:40.858Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:40.861Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:40.862Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:40.872Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:33:48.809Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:33:58.250Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:33:58.358Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:33:58.359Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:33:58.360Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:33:58.360Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:33:58.379Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:33:58.380Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:33:58.422Z"}
debug: Executing (3e9f31a3-c9da-4688-a7bf-7daedeabd23f): START TRANSACTION; {"timestamp":"2023-08-15T07:33:58.423Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:58.423Z"}
debug: Executing (3e9f31a3-c9da-4688-a7bf-7daedeabd23f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:33:58.428Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:58.433Z"}
debug: Executing (3e9f31a3-c9da-4688-a7bf-7daedeabd23f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_5e4dcd34bb4644bb89f392772d501ba1$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:33:58.435 +00:00','2023-08-15 07:33:58.435 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_5e4dcd34bb4644bb89f392772d501ba1$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:33:58.439Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:58.440Z"}
debug: Executing (3e9f31a3-c9da-4688-a7bf-7daedeabd23f): COMMIT; {"timestamp":"2023-08-15T07:33:58.445Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:58.445Z"}
info: User Already exists {"timestamp":"2023-08-15T07:33:58.447Z"}
info: User Created {"timestamp":"2023-08-15T07:33:58.448Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:58.451Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:58.468Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:58.478Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:33:58.485Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:58.491Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:58.492Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:58.493Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:58.494Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:33:58.496Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:58.499Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:58.509Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:33:58.515Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:58.517Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:58.523Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:33:58.526Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:58.527Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:58.537Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:33:58.540Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:33:58.542Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:33:58.553Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:33:59.406Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:33:59.977Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:34:00.718Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:34:01.105Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:34:01.292Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:34:01.474Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = '700bbb27e8ca78860938be37b2f6bc3a')) LIMIT 1; {"timestamp":"2023-08-15T07:34:01.628Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = 'a5c0119d1d351f820bd04c8f8166bd19')) LIMIT 1; {"timestamp":"2023-08-15T07:34:15.713Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND ("users"."email" = 'admin@admin.com' AND "users"."password" = 'a5c0119d1d351f820bd04c8f8166bd19')) LIMIT 1; {"timestamp":"2023-08-15T07:35:03.518Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:37:15.912Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:37:16.015Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:37:16.015Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:37:16.016Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:37:16.017Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:37:16.034Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:37:16.034Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:37:16.075Z"}
debug: Executing (7af91332-6166-42bf-aa86-1e1517559b59): START TRANSACTION; {"timestamp":"2023-08-15T07:37:16.075Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:16.076Z"}
debug: Executing (7af91332-6166-42bf-aa86-1e1517559b59): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:37:16.082Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:16.086Z"}
debug: Executing (7af91332-6166-42bf-aa86-1e1517559b59): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_77844c97ba574dd7b6ffb782e3e5a78b$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:37:16.090 +00:00','2023-08-15 07:37:16.090 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_77844c97ba574dd7b6ffb782e3e5a78b$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:37:16.094Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:16.096Z"}
debug: Executing (7af91332-6166-42bf-aa86-1e1517559b59): COMMIT; {"timestamp":"2023-08-15T07:37:16.100Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:16.101Z"}
info: User Already exists {"timestamp":"2023-08-15T07:37:16.102Z"}
info: User Created {"timestamp":"2023-08-15T07:37:16.102Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:16.106Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:16.121Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:16.128Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:16.135Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:16.143Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:16.144Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:16.145Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:16.146Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:16.147Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:16.150Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:16.161Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:16.166Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:16.167Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:16.173Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:16.176Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:16.178Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:16.187Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:16.190Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:16.192Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:16.202Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:37:19.799Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:37:19.904Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:37:19.904Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:37:19.905Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:37:19.906Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:37:19.925Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:37:19.926Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:37:19.967Z"}
debug: Executing (3fcf5568-3c82-4f9c-bd4e-0a9e86753fc4): START TRANSACTION; {"timestamp":"2023-08-15T07:37:19.968Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:19.968Z"}
debug: Executing (3fcf5568-3c82-4f9c-bd4e-0a9e86753fc4): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:37:19.974Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:19.977Z"}
debug: Executing (3fcf5568-3c82-4f9c-bd4e-0a9e86753fc4): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_3f839249f22441e69d9322d0f2aef469$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:37:19.979 +00:00','2023-08-15 07:37:19.979 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_3f839249f22441e69d9322d0f2aef469$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:37:19.984Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:19.985Z"}
debug: Executing (3fcf5568-3c82-4f9c-bd4e-0a9e86753fc4): COMMIT; {"timestamp":"2023-08-15T07:37:19.990Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:19.990Z"}
info: User Already exists {"timestamp":"2023-08-15T07:37:19.991Z"}
info: User Created {"timestamp":"2023-08-15T07:37:19.992Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:19.995Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:20.010Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:20.017Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:20.023Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:20.031Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:20.032Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:20.033Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:20.034Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:20.035Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:20.038Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:20.048Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:20.053Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:20.055Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:20.061Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:20.065Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:20.066Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:20.076Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:20.078Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:20.079Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:20.089Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:37:28.614Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:37:28.722Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:37:28.722Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:37:28.723Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:37:28.724Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:37:28.743Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:37:28.744Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:37:28.784Z"}
debug: Executing (c326f954-75e7-4542-b961-e449d8acf144): START TRANSACTION; {"timestamp":"2023-08-15T07:37:28.787Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:28.789Z"}
debug: Executing (c326f954-75e7-4542-b961-e449d8acf144): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:37:28.794Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:28.798Z"}
debug: Executing (c326f954-75e7-4542-b961-e449d8acf144): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_85ee178c1482447db78dcb2bb86fc9b8$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:37:28.800 +00:00','2023-08-15 07:37:28.800 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_85ee178c1482447db78dcb2bb86fc9b8$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:37:28.806Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:28.807Z"}
debug: Executing (c326f954-75e7-4542-b961-e449d8acf144): COMMIT; {"timestamp":"2023-08-15T07:37:28.813Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:28.814Z"}
info: User Already exists {"timestamp":"2023-08-15T07:37:28.815Z"}
info: User Created {"timestamp":"2023-08-15T07:37:28.815Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:28.819Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:28.835Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:28.844Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:28.850Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:28.857Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:28.859Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:28.860Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:28.861Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:28.862Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:28.865Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:28.875Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:28.880Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:28.882Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:28.887Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:28.891Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:28.893Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:28.903Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:28.906Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:28.908Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:28.919Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL); {"timestamp":"2023-08-15T07:37:30.505Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:37:53.444Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:37:53.540Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:37:53.540Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:37:53.541Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:37:53.542Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:37:53.560Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:37:53.561Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:37:53.600Z"}
debug: Executing (484eafd2-b60f-4fd7-a048-3253793d2a2f): START TRANSACTION; {"timestamp":"2023-08-15T07:37:53.601Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:53.602Z"}
debug: Executing (484eafd2-b60f-4fd7-a048-3253793d2a2f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:37:53.608Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:53.611Z"}
debug: Executing (484eafd2-b60f-4fd7-a048-3253793d2a2f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_03c0026f47f2485990d704fcc3ee15e5$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:37:53.614 +00:00','2023-08-15 07:37:53.614 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_03c0026f47f2485990d704fcc3ee15e5$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:37:53.618Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:53.620Z"}
debug: Executing (484eafd2-b60f-4fd7-a048-3253793d2a2f): COMMIT; {"timestamp":"2023-08-15T07:37:53.624Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:53.624Z"}
info: User Already exists {"timestamp":"2023-08-15T07:37:53.626Z"}
info: User Created {"timestamp":"2023-08-15T07:37:53.626Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:53.629Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:53.645Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:53.652Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:37:53.660Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:53.666Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:53.668Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:53.670Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:53.671Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:37:53.673Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:53.676Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:53.685Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:37:53.691Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:53.693Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:53.698Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:37:53.701Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:53.703Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:53.712Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:37:53.715Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:37:53.717Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:37:53.727Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:38:05.478Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:38:05.583Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:38:05.584Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:38:05.585Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:38:05.586Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:38:05.606Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:38:05.607Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:38:05.649Z"}
debug: Executing (a6601b00-e58e-425d-9910-034c7e76b68f): START TRANSACTION; {"timestamp":"2023-08-15T07:38:05.649Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:05.650Z"}
debug: Executing (a6601b00-e58e-425d-9910-034c7e76b68f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:38:05.657Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:05.661Z"}
debug: Executing (a6601b00-e58e-425d-9910-034c7e76b68f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_7dc84dbdef3544e39c508c56588593e0$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:38:05.663 +00:00','2023-08-15 07:38:05.663 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_7dc84dbdef3544e39c508c56588593e0$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:38:05.667Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:05.669Z"}
debug: Executing (a6601b00-e58e-425d-9910-034c7e76b68f): COMMIT; {"timestamp":"2023-08-15T07:38:05.674Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:05.675Z"}
info: User Already exists {"timestamp":"2023-08-15T07:38:05.680Z"}
info: User Created {"timestamp":"2023-08-15T07:38:05.680Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:05.681Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:05.698Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:05.706Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:05.712Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:05.719Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:05.721Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:05.722Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:05.723Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:05.724Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:05.727Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:05.737Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:05.743Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:05.744Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:05.749Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:05.753Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:05.755Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:05.764Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:05.767Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:05.769Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:05.779Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:38:18.139Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:38:18.247Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:38:18.248Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:38:18.249Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:38:18.249Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:38:18.267Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:38:18.268Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:38:18.327Z"}
debug: Executing (88a3925c-11c6-43e8-a971-01a65a9b6462): START TRANSACTION; {"timestamp":"2023-08-15T07:38:18.328Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:18.329Z"}
debug: Executing (88a3925c-11c6-43e8-a971-01a65a9b6462): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:38:18.336Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:18.341Z"}
debug: Executing (88a3925c-11c6-43e8-a971-01a65a9b6462): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_a2f497c6ecde41be80edbc80fc313dbf$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:38:18.344 +00:00','2023-08-15 07:38:18.344 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_a2f497c6ecde41be80edbc80fc313dbf$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:38:18.350Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:18.351Z"}
debug: Executing (88a3925c-11c6-43e8-a971-01a65a9b6462): COMMIT; {"timestamp":"2023-08-15T07:38:18.356Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:18.357Z"}
info: User Already exists {"timestamp":"2023-08-15T07:38:18.362Z"}
info: User Created {"timestamp":"2023-08-15T07:38:18.362Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:18.363Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:18.380Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:18.387Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:18.394Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:18.401Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:18.403Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:18.404Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:18.405Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:18.407Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:18.410Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:18.421Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:18.426Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:18.428Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:18.433Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:18.437Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:18.439Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:18.449Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:18.451Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:18.453Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:18.466Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:38:33.591Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:38:33.720Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:38:33.720Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:38:33.721Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:38:33.721Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:38:33.745Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:38:33.746Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:38:33.802Z"}
debug: Executing (f81fd58f-d2ca-4dac-b134-07a479a92ee1): START TRANSACTION; {"timestamp":"2023-08-15T07:38:33.806Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:33.807Z"}
debug: Executing (f81fd58f-d2ca-4dac-b134-07a479a92ee1): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:38:33.814Z"}
debug: Executing (f81fd58f-d2ca-4dac-b134-07a479a92ee1): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_7489b40e77bf472caf0b9a2e78ea68f9$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:38:33.822 +00:00','2023-08-15 07:38:33.822 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_7489b40e77bf472caf0b9a2e78ea68f9$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:38:33.831Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:33.832Z"}
debug: Executing (f81fd58f-d2ca-4dac-b134-07a479a92ee1): COMMIT; {"timestamp":"2023-08-15T07:38:33.840Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:33.842Z"}
info: User Already exists {"timestamp":"2023-08-15T07:38:33.848Z"}
info: User Created {"timestamp":"2023-08-15T07:38:33.849Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:33.850Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:33.858Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:33.881Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:33.891Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:38:33.901Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:33.912Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:33.914Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:33.915Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:33.918Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:38:33.920Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:33.924Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:33.937Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:38:33.945Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:33.947Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:33.955Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:38:33.959Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:33.962Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:33.976Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:38:33.980Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:38:33.982Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:38:33.997Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:39:03.008Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:39:03.110Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:39:03.111Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:39:03.111Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:39:03.112Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:39:03.127Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:39:03.128Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:39:03.169Z"}
debug: Executing (731a5c32-c364-4976-96f3-7a07468e7549): START TRANSACTION; {"timestamp":"2023-08-15T07:39:03.170Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:03.171Z"}
debug: Executing (731a5c32-c364-4976-96f3-7a07468e7549): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:39:03.179Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:03.181Z"}
debug: Executing (731a5c32-c364-4976-96f3-7a07468e7549): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_f9d66e62e6f6426391a0a8f5d7cd58a1$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:39:03.185 +00:00','2023-08-15 07:39:03.185 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_f9d66e62e6f6426391a0a8f5d7cd58a1$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:39:03.189Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:03.190Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:03.194Z"}
debug: Executing (731a5c32-c364-4976-96f3-7a07468e7549): COMMIT; {"timestamp":"2023-08-15T07:39:03.196Z"}
info: User Already exists {"timestamp":"2023-08-15T07:39:03.203Z"}
info: User Created {"timestamp":"2023-08-15T07:39:03.203Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:03.204Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:03.220Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:03.227Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:03.234Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:03.242Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:03.243Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:03.244Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:03.245Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:03.247Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:03.250Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:03.259Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:03.265Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:03.267Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:03.273Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:03.276Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:03.277Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:03.287Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:03.289Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:03.291Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:03.301Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:39:24.151Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:39:24.251Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:39:24.251Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:39:24.252Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:39:24.252Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:39:24.271Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:39:24.272Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:39:24.310Z"}
debug: Executing (173ae999-fe51-40f5-9a3e-a9d69bad3203): START TRANSACTION; {"timestamp":"2023-08-15T07:39:24.312Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:24.313Z"}
debug: Executing (173ae999-fe51-40f5-9a3e-a9d69bad3203): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:39:24.319Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:24.323Z"}
debug: Executing (173ae999-fe51-40f5-9a3e-a9d69bad3203): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_94772c715c8948c88b315ac2a0a424cf$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:39:24.325 +00:00','2023-08-15 07:39:24.325 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_94772c715c8948c88b315ac2a0a424cf$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:39:24.328Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:24.329Z"}
debug: Executing (173ae999-fe51-40f5-9a3e-a9d69bad3203): COMMIT; {"timestamp":"2023-08-15T07:39:24.334Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:24.335Z"}
info: User Already exists {"timestamp":"2023-08-15T07:39:24.341Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:39:33.989Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:39:34.088Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:39:34.089Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:39:34.090Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:39:34.090Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:39:34.108Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:39:34.108Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:39:34.149Z"}
debug: Executing (4cfb01e5-92ef-4b5e-88e2-e2f523a47acc): START TRANSACTION; {"timestamp":"2023-08-15T07:39:34.150Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:34.151Z"}
debug: Executing (4cfb01e5-92ef-4b5e-88e2-e2f523a47acc): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:39:34.156Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:34.157Z"}
debug: Executing (4cfb01e5-92ef-4b5e-88e2-e2f523a47acc): COMMIT; {"timestamp":"2023-08-15T07:39:34.159Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:34.159Z"}
error: Error authenticating Postgress Db relation "users" does not exist {"name":"SequelizeDatabaseError","original":{"code":"42P01","file":"parse_relation.c","length":104,"line":"1381","name":"error","position":"94","routine":"parserOpenTable","severity":"ERROR","sql":"SELECT \"id\", \"name\", \"email\", \"password\", \"role\", \"createdAt\", \"updatedAt\", \"deletedAt\" FROM \"users\" AS \"users\" WHERE (\"users\".\"deletedAt\" IS NULL AND \"users\".\"name\" = 'admin') LIMIT 1;"},"parameters":{},"parent":{"code":"42P01","file":"parse_relation.c","length":104,"line":"1381","name":"error","position":"94","routine":"parserOpenTable","severity":"ERROR","sql":"SELECT \"id\", \"name\", \"email\", \"password\", \"role\", \"createdAt\", \"updatedAt\", \"deletedAt\" FROM \"users\" AS \"users\" WHERE (\"users\".\"deletedAt\" IS NULL AND \"users\".\"name\" = 'admin') LIMIT 1;"},"sql":"SELECT \"id\", \"name\", \"email\", \"password\", \"role\", \"createdAt\", \"updatedAt\", \"deletedAt\" FROM \"users\" AS \"users\" WHERE (\"users\".\"deletedAt\" IS NULL AND \"users\".\"name\" = 'admin') LIMIT 1;","stack":"Error\n    at Query.run (D:\\esa\\backend\\node_modules\\sequelize\\lib\\dialects\\postgres\\query.js:50:25)\n    at D:\\esa\\backend\\node_modules\\sequelize\\lib\\sequelize.js:315:28\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async PostgresQueryInterface.select (D:\\esa\\backend\\node_modules\\sequelize\\lib\\dialects\\abstract\\query-interface.js:407:12)\n    at async users.findAll (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1140:21)\n    at async users.findOne (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1240:12)\n    at async users.findOrCreate (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1411:21)\n    at async connect (D:\\esa\\backend\\index.js:79:33)","timestamp":"2023-08-15T07:39:34.160Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:34.163Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:34.165Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:34.182Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:34.189Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:34.197Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:34.206Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:34.207Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:34.208Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:34.209Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:34.211Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:34.213Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:34.224Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:34.231Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:34.232Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:34.239Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:34.242Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:34.243Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:34.253Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:34.255Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:34.257Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:34.267Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:39:37.473Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:39:37.571Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:39:37.571Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:39:37.572Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:39:37.572Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:39:37.592Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:39:37.593Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:39:37.638Z"}
debug: Executing (17a2f207-8605-4f48-8c59-054b7cc94223): START TRANSACTION; {"timestamp":"2023-08-15T07:39:37.639Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:37.640Z"}
debug: Executing (17a2f207-8605-4f48-8c59-054b7cc94223): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:39:37.648Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:37.650Z"}
debug: Executing (17a2f207-8605-4f48-8c59-054b7cc94223): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_a77449b0f2904de39a1b5dec085d9616$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:39:37.653 +00:00','2023-08-15 07:39:37.653 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_a77449b0f2904de39a1b5dec085d9616$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:39:37.657Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:37.658Z"}
debug: Executing (17a2f207-8605-4f48-8c59-054b7cc94223): COMMIT; {"timestamp":"2023-08-15T07:39:37.663Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:37.663Z"}
info: User Already exists {"timestamp":"2023-08-15T07:39:37.669Z"}
info: User Created {"timestamp":"2023-08-15T07:39:37.669Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:37.670Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:37.686Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:37.693Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:39:37.699Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:37.707Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:37.708Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:37.709Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:37.710Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:39:37.711Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:37.714Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:37.724Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:39:37.730Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:37.731Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:37.737Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:39:37.740Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:37.742Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:37.751Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:39:37.754Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:39:37.755Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:39:37.765Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL); {"timestamp":"2023-08-15T07:39:40.232Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL); {"timestamp":"2023-08-15T07:39:40.757Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL); {"timestamp":"2023-08-15T07:39:41.093Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL); {"timestamp":"2023-08-15T07:39:41.270Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL); {"timestamp":"2023-08-15T07:39:41.432Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:41:53.273Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:41:53.370Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:41:53.370Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:41:53.371Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:41:53.372Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:41:53.389Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:41:53.390Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:41:53.432Z"}
debug: Executing (7c6125c1-bb6e-47db-87e7-83f1a67e7201): START TRANSACTION; {"timestamp":"2023-08-15T07:41:53.435Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:41:53.435Z"}
debug: Executing (7c6125c1-bb6e-47db-87e7-83f1a67e7201): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:41:53.441Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:41:53.441Z"}
debug: Executing (7c6125c1-bb6e-47db-87e7-83f1a67e7201): COMMIT; {"timestamp":"2023-08-15T07:41:53.444Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:41:53.445Z"}
error: Error authenticating Postgress Db relation "users" does not exist {"name":"SequelizeDatabaseError","original":{"code":"42P01","file":"parse_relation.c","length":104,"line":"1381","name":"error","position":"94","routine":"parserOpenTable","severity":"ERROR","sql":"SELECT \"id\", \"name\", \"email\", \"password\", \"role\", \"createdAt\", \"updatedAt\", \"deletedAt\" FROM \"users\" AS \"users\" WHERE (\"users\".\"deletedAt\" IS NULL AND \"users\".\"name\" = 'admin') LIMIT 1;"},"parameters":{},"parent":{"code":"42P01","file":"parse_relation.c","length":104,"line":"1381","name":"error","position":"94","routine":"parserOpenTable","severity":"ERROR","sql":"SELECT \"id\", \"name\", \"email\", \"password\", \"role\", \"createdAt\", \"updatedAt\", \"deletedAt\" FROM \"users\" AS \"users\" WHERE (\"users\".\"deletedAt\" IS NULL AND \"users\".\"name\" = 'admin') LIMIT 1;"},"sql":"SELECT \"id\", \"name\", \"email\", \"password\", \"role\", \"createdAt\", \"updatedAt\", \"deletedAt\" FROM \"users\" AS \"users\" WHERE (\"users\".\"deletedAt\" IS NULL AND \"users\".\"name\" = 'admin') LIMIT 1;","stack":"Error\n    at Query.run (D:\\esa\\backend\\node_modules\\sequelize\\lib\\dialects\\postgres\\query.js:50:25)\n    at D:\\esa\\backend\\node_modules\\sequelize\\lib\\sequelize.js:315:28\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async PostgresQueryInterface.select (D:\\esa\\backend\\node_modules\\sequelize\\lib\\dialects\\abstract\\query-interface.js:407:12)\n    at async users.findAll (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1140:21)\n    at async users.findOne (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1240:12)\n    at async users.findOrCreate (D:\\esa\\backend\\node_modules\\sequelize\\lib\\model.js:1411:21)\n    at async connect (D:\\esa\\backend\\index.js:79:33)","timestamp":"2023-08-15T07:41:53.445Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:41:53.449Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:41:53.450Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:41:53.467Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:41:53.474Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:41:53.480Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:41:53.488Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:41:53.489Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:41:53.490Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:41:53.491Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:41:53.492Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:41:53.495Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:41:53.510Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:41:53.516Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:41:53.518Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:41:53.523Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:41:53.527Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:41:53.529Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:41:53.539Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:41:53.544Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:41:53.546Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:41:53.560Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:42:24.002Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:42:24.130Z"}
info: App listening to port http://localhost:3500 {"timestamp":"2023-08-15T07:42:24.131Z"}
info: ================================================================ {"timestamp":"2023-08-15T07:42:24.132Z"}
info: Trying to connect to Redis {"timestamp":"2023-08-15T07:42:24.133Z"}
info: Redis Connectin Successful {"timestamp":"2023-08-15T07:42:24.178Z"}
info: Redis store initialized {"timestamp":"2023-08-15T07:42:24.178Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:42:24.231Z"}
debug: Executing (8e95d44a-687f-423e-b2dc-3c101ca96ae3): START TRANSACTION; {"timestamp":"2023-08-15T07:42:24.232Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:42:24.235Z"}
debug: Executing (8e95d44a-687f-423e-b2dc-3c101ca96ae3): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:42:24.240Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:42:24.245Z"}
debug: Executing (8e95d44a-687f-423e-b2dc-3c101ca96ae3): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_258087b69dd04546855f3662503183b2$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:42:24.247 +00:00','2023-08-15 07:42:24.247 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_258087b69dd04546855f3662503183b2$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:42:24.252Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:42:24.253Z"}
debug: Executing (8e95d44a-687f-423e-b2dc-3c101ca96ae3): COMMIT; {"timestamp":"2023-08-15T07:42:24.258Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:42:24.259Z"}
info: User Already exists {"timestamp":"2023-08-15T07:42:24.265Z"}
info: User Created {"timestamp":"2023-08-15T07:42:24.265Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:42:24.266Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:42:24.282Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:42:24.289Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:42:24.295Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:42:24.303Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:42:24.304Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:42:24.305Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:42:24.306Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:42:24.307Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:42:24.310Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:42:24.320Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:42:24.325Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:42:24.327Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:42:24.333Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:42:24.336Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:42:24.337Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:42:24.347Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:42:24.349Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:42:24.351Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:42:24.361Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL); {"timestamp":"2023-08-15T07:42:42.659Z"}
debug: Executing (default): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL); {"timestamp":"2023-08-15T07:42:43.106Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:44:03.367Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:44:03.524Z"}
debug: Executing (d4084273-7d19-4463-942c-199afe6c087f): START TRANSACTION; {"timestamp":"2023-08-15T07:44:03.525Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:44:03.526Z"}
debug: Executing (d4084273-7d19-4463-942c-199afe6c087f): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:44:03.532Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:44:03.535Z"}
debug: Executing (d4084273-7d19-4463-942c-199afe6c087f): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_f8f4a2e96a9e4eebaf0b2d9c5dddbaa4$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:44:03.537 +00:00','2023-08-15 07:44:03.537 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_f8f4a2e96a9e4eebaf0b2d9c5dddbaa4$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:44:03.542Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:44:03.543Z"}
debug: Executing (d4084273-7d19-4463-942c-199afe6c087f): COMMIT; {"timestamp":"2023-08-15T07:44:03.548Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:44:03.549Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:44:03.555Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:44:03.571Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:44:03.579Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:44:03.586Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:44:03.593Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:44:03.594Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:44:03.596Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:44:03.596Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:44:03.598Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:44:03.601Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:44:03.611Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:44:03.616Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:44:03.618Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:44:03.623Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:44:03.627Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:44:03.629Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:44:03.638Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:44:03.641Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:44:03.644Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:44:03.659Z"}
info: Initialized sequelize connection {"timestamp":"2023-08-15T07:44:07.021Z"}
debug: Executing (default): SELECT 1+1 AS result {"timestamp":"2023-08-15T07:44:07.191Z"}
debug: Executing (5eccfa34-a5da-4ccb-b5d1-f44328eaa4ad): START TRANSACTION; {"timestamp":"2023-08-15T07:44:07.193Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:44:07.194Z"}
debug: Executing (5eccfa34-a5da-4ccb-b5d1-f44328eaa4ad): SELECT "id", "name", "email", "password", "role", "createdAt", "updatedAt", "deletedAt" FROM "users" AS "users" WHERE ("users"."deletedAt" IS NULL AND "users"."name" = 'admin') LIMIT 1; {"timestamp":"2023-08-15T07:44:07.202Z"}
debug: Executing (5eccfa34-a5da-4ccb-b5d1-f44328eaa4ad): CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response "users", OUT sequelize_caught_exception text) RETURNS RECORD AS $func_e324b89e4ed6491bb4373e5d61754513$ BEGIN INSERT INTO "users" ("id","name","email","password","role","createdAt","updatedAt") VALUES (DEFAULT,'admin','admin@admin.com','a5c0119d1d351f820bd04c8f8166bd19','admin','2023-08-15 07:44:07.208 +00:00','2023-08-15 07:44:07.208 +00:00') RETURNING * INTO response; EXCEPTION WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL; END $func_e324b89e4ed6491bb4373e5d61754513$ LANGUAGE plpgsql; SELECT (testfunc.response)."id", (testfunc.response)."name", (testfunc.response)."email", (testfunc.response)."password", (testfunc.response)."role", (testfunc.response)."createdAt", (testfunc.response)."updatedAt", (testfunc.response)."deletedAt", testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc(); {"timestamp":"2023-08-15T07:44:07.212Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:44:07.213Z"}
debug: Executing (5eccfa34-a5da-4ccb-b5d1-f44328eaa4ad): COMMIT; {"timestamp":"2023-08-15T07:44:07.218Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:44:07.219Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:44:07.225Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:44:07.230Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'class' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:44:07.246Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'students' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:44:07.253Z"}
debug: Executing (default): SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'voucher' AND tc.table_catalog = 'edubiz' {"timestamp":"2023-08-15T07:44:07.260Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:44:07.267Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:44:07.268Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:44:07.269Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:44:07.270Z"}
debug: Executing (default): DROP TABLE IF EXISTS "users" CASCADE; {"timestamp":"2023-08-15T07:44:07.272Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "users" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "email" VARCHAR(255) NOT NULL, "password" VARCHAR(255) NOT NULL, "role" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:44:07.275Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:44:07.286Z"}
debug: Executing (default): DROP TABLE IF EXISTS "class" CASCADE; {"timestamp":"2023-08-15T07:44:07.292Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "class" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:44:07.293Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'class' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:44:07.299Z"}
debug: Executing (default): DROP TABLE IF EXISTS "students" CASCADE; {"timestamp":"2023-08-15T07:44:07.302Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "students" ("id"  SERIAL UNIQUE , "name" VARCHAR(255) NOT NULL, "father_name" VARCHAR(255) NOT NULL, "email_address" VARCHAR(255) NOT NULL, "address" VARCHAR(255) NOT NULL, "phone_1" VARCHAR(255), "phone_2" VARCHAR(255), "phone_3" VARCHAR(255), "avatar" VARCHAR(255), "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:44:07.303Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'students' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:44:07.314Z"}
debug: Executing (default): DROP TABLE IF EXISTS "voucher" CASCADE; {"timestamp":"2023-08-15T07:44:07.316Z"}
debug: Executing (default): CREATE TABLE IF NOT EXISTS "voucher" ("id"   SERIAL , "data_issued" DATE NOT NULL, "date_expiry" DATE NOT NULL, "config" JSON NOT NULL, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, "deletedAt" TIMESTAMP WITH TIME ZONE, "classId" INTEGER REFERENCES "class" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "studentId" INTEGER REFERENCES "students" ("id") ON DELETE SET NULL ON UPDATE CASCADE, PRIMARY KEY ("id")); {"timestamp":"2023-08-15T07:44:07.318Z"}
debug: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'voucher' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname; {"timestamp":"2023-08-15T07:44:07.329Z"}
